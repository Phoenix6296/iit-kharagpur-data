(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_3e6e1a33._.js", {

"[project]/node_modules/ml-distance-euclidean/lib-es6/euclidean.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "euclidean": (()=>euclidean),
    "squaredEuclidean": (()=>squaredEuclidean)
});
function squaredEuclidean(p, q) {
    let d = 0;
    for(let i = 0; i < p.length; i++){
        d += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return d;
}
function euclidean(p, q) {
    return Math.sqrt(squaredEuclidean(p, q));
}
}}),
"[project]/node_modules/ml-knn/src/KDTree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Original code from:
 *
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */ __turbopack_context__.s({
    "default": (()=>KDTree)
});
function Node(obj, dimension, parent) {
    this.obj = obj;
    this.left = null;
    this.right = null;
    this.parent = parent;
    this.dimension = dimension;
}
class KDTree {
    constructor(points, metric){
        // If points is not an array, assume we're loading a pre-built tree
        if (!Array.isArray(points)) {
            this.dimensions = points.dimensions;
            this.root = points;
            restoreParent(this.root);
        } else {
            this.dimensions = new Array(points[0].length);
            for(var i = 0; i < this.dimensions.length; i++){
                this.dimensions[i] = i;
            }
            this.root = buildTree(points, 0, null, this.dimensions);
        }
        this.metric = metric;
    }
    // Convert to a JSON serializable structure; this just requires removing
    // the `parent` property
    toJSON() {
        const result = toJSONImpl(this.root, true);
        result.dimensions = this.dimensions;
        return result;
    }
    nearest(point, maxNodes, maxDistance) {
        const metric = this.metric;
        const dimensions = this.dimensions;
        var i;
        const bestNodes = new BinaryHeap(function(e) {
            return -e[1];
        });
        function nearestSearch(node) {
            const dimension = dimensions[node.dimension];
            const ownDistance = metric(point, node.obj);
            const linearPoint = {};
            var bestChild, linearDistance, otherChild, i;
            function saveNode(node, distance) {
                bestNodes.push([
                    node,
                    distance
                ]);
                if (bestNodes.size() > maxNodes) {
                    bestNodes.pop();
                }
            }
            for(i = 0; i < dimensions.length; i += 1){
                if (i === node.dimension) {
                    linearPoint[dimensions[i]] = point[dimensions[i]];
                } else {
                    linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                }
            }
            linearDistance = metric(linearPoint, node.obj);
            if (node.right === null && node.left === null) {
                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                    saveNode(node, ownDistance);
                }
                return;
            }
            if (node.right === null) {
                bestChild = node.left;
            } else if (node.left === null) {
                bestChild = node.right;
            } else {
                if (point[dimension] < node.obj[dimension]) {
                    bestChild = node.left;
                } else {
                    bestChild = node.right;
                }
            }
            nearestSearch(bestChild);
            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                saveNode(node, ownDistance);
            }
            if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                if (bestChild === node.left) {
                    otherChild = node.right;
                } else {
                    otherChild = node.left;
                }
                if (otherChild !== null) {
                    nearestSearch(otherChild);
                }
            }
        }
        if (maxDistance) {
            for(i = 0; i < maxNodes; i += 1){
                bestNodes.push([
                    null,
                    maxDistance
                ]);
            }
        }
        if (this.root) {
            nearestSearch(this.root);
        }
        const result = [];
        for(i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1){
            if (bestNodes.content[i][0]) {
                result.push([
                    bestNodes.content[i][0].obj,
                    bestNodes.content[i][1]
                ]);
            }
        }
        return result;
    }
}
function toJSONImpl(src) {
    const dest = new Node(src.obj, src.dimension, null);
    if (src.left) dest.left = toJSONImpl(src.left);
    if (src.right) dest.right = toJSONImpl(src.right);
    return dest;
}
function buildTree(points, depth, parent, dimensions) {
    const dim = depth % dimensions.length;
    if (points.length === 0) {
        return null;
    }
    if (points.length === 1) {
        return new Node(points[0], dim, parent);
    }
    points.sort((a, b)=>a[dimensions[dim]] - b[dimensions[dim]]);
    const median = Math.floor(points.length / 2);
    const node = new Node(points[median], dim, parent);
    node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);
    node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);
    return node;
}
function restoreParent(root) {
    if (root.left) {
        root.left.parent = root;
        restoreParent(root.left);
    }
    if (root.right) {
        root.right.parent = root;
        restoreParent(root.right);
    }
}
// Binary heap implementation from:
// http://eloquentjavascript.net/appendix2.html
class BinaryHeap {
    constructor(scoreFunction){
        this.content = [];
        this.scoreFunction = scoreFunction;
    }
    push(element) {
        // Add the new element to the end of the array.
        this.content.push(element);
        // Allow it to bubble up.
        this.bubbleUp(this.content.length - 1);
    }
    pop() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it sink down.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
        }
        return result;
    }
    peek() {
        return this.content[0];
    }
    size() {
        return this.content.length;
    }
    bubbleUp(n) {
        // Fetch the element that has to be moved.
        var element = this.content[n];
        // When at 0, an element can not go up any further.
        while(n > 0){
            // Compute the parent element's index, and fetch it.
            const parentN = Math.floor((n + 1) / 2) - 1;
            const parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            } else {
                break;
            }
        }
    }
    sinkDown(n) {
        // Look up the target element and its score.
        var length = this.content.length;
        var element = this.content[n];
        var elemScore = this.scoreFunction(element);
        while(true){
            // Compute the indices of the child elements.
            var child2N = (n + 1) * 2;
            var child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                var child1Score = this.scoreFunction(child1);
                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore) {
                    swap = child1N;
                }
            }
            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N];
                var child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }
            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            } else {
                break;
            }
        }
    }
}
}}),
"[project]/node_modules/ml-knn/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>KNN)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-distance-euclidean/lib-es6/euclidean.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-knn/src/KDTree.js [app-client] (ecmascript)");
;
;
class KNN {
    /**
   * @param {Array} dataset
   * @param {Array} labels
   * @param {object} options
   * @param {number} [options.k=numberOfClasses + 1] - Number of neighbors to classify.
   * @param {function} [options.distance=euclideanDistance] - Distance function that takes two parameters.
   */ constructor(dataset, labels, options = {}){
        if (dataset === true) {
            const model = labels;
            this.kdTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.kdTree, options);
            this.k = model.k;
            this.classes = new Set(model.classes);
            this.isEuclidean = model.isEuclidean;
            return;
        }
        const classes = new Set(labels);
        const { distance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"], k = classes.size + 1 } = options;
        const points = new Array(dataset.length);
        for(var i = 0; i < points.length; ++i){
            points[i] = dataset[i].slice();
        }
        for(i = 0; i < labels.length; ++i){
            points[i].push(labels[i]);
        }
        this.kdTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](points, distance);
        this.k = k;
        this.classes = classes;
        this.isEuclidean = distance === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"];
    }
    /**
   * Create a new KNN instance with the given model.
   * @param {object} model
   * @param {function} distance=euclideanDistance - distance function must be provided if the model wasn't trained with euclidean distance.
   * @return {KNN}
   */ static load(model, distance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
        if (model.name !== 'KNN') {
            throw new Error(`invalid model: ${model.name}`);
        }
        if (!model.isEuclidean && distance === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
            throw new Error('a custom distance function was used to create the model. Please provide it again');
        }
        if (model.isEuclidean && distance !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
            throw new Error('the model was created with the default distance function. Do not load it with another one');
        }
        return new KNN(true, model, distance);
    }
    /**
   * Return a JSON containing the kd-tree model.
   * @return {object} JSON KNN model.
   */ toJSON() {
        return {
            name: 'KNN',
            kdTree: this.kdTree,
            k: this.k,
            classes: Array.from(this.classes),
            isEuclidean: this.isEuclidean
        };
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Array} dataset
   * @return {Array} predictions
   */ predict(dataset) {
        if (Array.isArray(dataset)) {
            if (typeof dataset[0] === 'number') {
                return getSinglePrediction(this, dataset);
            } else if (Array.isArray(dataset[0]) && typeof dataset[0][0] === 'number') {
                const predictions = new Array(dataset.length);
                for(var i = 0; i < dataset.length; i++){
                    predictions[i] = getSinglePrediction(this, dataset[i]);
                }
                return predictions;
            }
        }
        throw new TypeError('dataset to predict must be an array or a matrix');
    }
}
function getSinglePrediction(knn, currentCase) {
    var nearestPoints = knn.kdTree.nearest(currentCase, knn.k);
    var pointsPerClass = {};
    var predictedClass = -1;
    var maxPoints = -1;
    var lastElement = nearestPoints[0][0].length - 1;
    for (var element of knn.classes){
        pointsPerClass[element] = 0;
    }
    for(var i = 0; i < nearestPoints.length; ++i){
        var currentClass = nearestPoints[i][0][lastElement];
        var currentPoints = ++pointsPerClass[currentClass];
        if (currentPoints > maxPoints) {
            predictedClass = currentClass;
            maxPoints = currentPoints;
        }
    }
    return predictedClass;
}
}}),
"[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// eslint-disable-next-line @typescript-eslint/unbound-method
__turbopack_context__.s({
    "isAnyArray": (()=>isAnyArray)
});
const toString = Object.prototype.toString;
function isAnyArray(value) {
    const tag = toString.call(value);
    return tag.endsWith('Array]') && !tag.includes('Big');
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/ml-array-max/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>max)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function max(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
    if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
    }
    if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
    }
    var maxValue = input[fromIndex];
    for(var i = fromIndex + 1; i < toIndex; i++){
        if (input[i] > maxValue) maxValue = input[i];
    }
    return maxValue;
}
;
}}),
"[project]/node_modules/ml-array-min/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>min)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function min(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
    if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
    }
    if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
    }
    var minValue = input[fromIndex];
    for(var i = fromIndex + 1; i < toIndex; i++){
        if (input[i] < minValue) minValue = input[i];
    }
    return minValue;
}
;
}}),
"[project]/node_modules/ml-array-rescale/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>rescale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$max$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-max/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$min$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-min/lib-es6/index.js [app-client] (ecmascript)");
;
;
;
function rescale(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    } else if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var output;
    if (options.output !== undefined) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(options.output)) {
            throw new TypeError('output option must be an array if specified');
        }
        output = options.output;
    } else {
        output = new Array(input.length);
    }
    var currentMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$min$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input);
    var currentMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$max$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input);
    if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
    }
    var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
    if (minValue >= maxValue) {
        throw new RangeError('min option must be smaller than max option');
    }
    var factor = (maxValue - minValue) / (currentMax - currentMin);
    for(var i = 0; i < input.length; i++){
        output[i] = (input[i] - currentMin) * factor + minValue;
    }
    return output;
}
;
}}),
"[project]/node_modules/ml-logistic-regression/src/logreg_2classes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>LogisticRegressionTwoClasses)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
;
class LogisticRegressionTwoClasses {
    constructor(options = {}){
        const { numSteps = 50000, learningRate = 5e-4, weights = null } = options;
        this.numSteps = numSteps;
        this.learningRate = learningRate;
        this.weights = weights ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].checkMatrix(weights) : null;
    }
    train(features, target) {
        let weights = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].zeros(1, features.columns);
        for(let step = 0; step < this.numSteps; step++){
            const scores = features.mmul(weights.transpose());
            const predictions = sigmoid(scores);
            // Update weights with gradient
            const outputErrorSignal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].columnVector(predictions).neg().add(target);
            const gradient = features.transpose().mmul(outputErrorSignal);
            weights = weights.add(gradient.mul(this.learningRate).transpose());
        }
        this.weights = weights;
    }
    testScores(features) {
        const finalData = features.mmul(this.weights.transpose());
        return sigmoid(finalData);
    }
    predict(features) {
        const finalData = features.mmul(this.weights.transpose());
        return sigmoid(finalData).map(Math.round);
    }
    static load(model) {
        return new LogisticRegressionTwoClasses(model);
    }
    toJSON() {
        return {
            numSteps: this.numSteps,
            learningRate: this.learningRate,
            weights: this.weights
        };
    }
}
function sigmoid(scores) {
    scores = scores.to1DArray();
    let result = [];
    for(let i = 0; i < scores.length; i++){
        result.push(1 / (1 + Math.exp(-scores[i])));
    }
    return result;
}
}}),
"[project]/node_modules/ml-logistic-regression/src/logreg.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>LogisticRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-logistic-regression/src/logreg_2classes.js [app-client] (ecmascript)");
;
;
function transformClassesForOneVsAll(Y, oneClass) {
    let y = Y.to1DArray();
    for(let i = 0; i < y.length; i++){
        if (y[i] === oneClass) {
            y[i] = 0;
        } else {
            y[i] = 1;
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].columnVector(y);
}
class LogisticRegression {
    constructor(options = {}){
        const { numSteps = 50000, learningRate = 5e-4, classifiers = [], numberClasses = 0 } = options;
        this.numSteps = numSteps;
        this.learningRate = learningRate;
        this.classifiers = classifiers;
        this.numberClasses = numberClasses;
    }
    train(X, Y) {
        this.numberClasses = new Set(Y.to1DArray()).size;
        this.classifiers = new Array(this.numberClasses);
        // train the classifiers
        for(let i = 0; i < this.numberClasses; i++){
            this.classifiers[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                numSteps: this.numSteps,
                learningRate: this.learningRate
            });
            let y = Y.clone();
            y = transformClassesForOneVsAll(y, i);
            this.classifiers[i].train(X, y);
        }
    }
    predict(Xtest) {
        let resultsOneClass = new Array(this.numberClasses).fill(0);
        let i;
        for(i = 0; i < this.numberClasses; i++){
            resultsOneClass[i] = this.classifiers[i].testScores(Xtest);
        }
        let finalResults = new Array(Xtest.rows).fill(0);
        for(i = 0; i < Xtest.rows; i++){
            let minimum = 100000;
            for(let j = 0; j < this.numberClasses; j++){
                if (resultsOneClass[j][i] < minimum) {
                    minimum = resultsOneClass[j][i];
                    finalResults[i] = j;
                }
            }
        }
        return finalResults;
    }
    static load(model) {
        if (model.name !== 'LogisticRegression') {
            throw new Error(`invalid model: ${model.name}`);
        }
        const newClassifier = new LogisticRegression(model);
        for(let i = 0; i < newClassifier.numberClasses; i++){
            newClassifier.classifiers[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].load(model.classifiers[i]);
        }
        return newClassifier;
    }
    toJSON() {
        return {
            name: 'LogisticRegression',
            numSteps: this.numSteps,
            learningRate: this.learningRate,
            numberClasses: this.numberClasses,
            classifiers: this.classifiers
        };
    }
}
}}),
"[project]/node_modules/ml-array-sum/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>sum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function sum(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var sumValue = 0;
    for(var i = 0; i < input.length; i++){
        sumValue += input[i];
    }
    return sumValue;
}
;
}}),
"[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>mean)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$sum$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-sum/lib-es6/index.js [app-client] (ecmascript)");
;
function mean(input) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$sum$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input) / input.length;
}
;
}}),
"[project]/node_modules/ml-cart/src/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getNumberOfClasses": (()=>getNumberOfClasses),
    "giniGain": (()=>giniGain),
    "giniImpurity": (()=>giniImpurity),
    "matrixSplitter": (()=>matrixSplitter),
    "mean": (()=>mean),
    "regressionError": (()=>regressionError),
    "squaredError": (()=>squaredError),
    "toDiscreteDistribution": (()=>toDiscreteDistribution),
    "zip": (()=>zip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
;
;
function toDiscreteDistribution(array, numberOfClasses) {
    let counts = new Array(numberOfClasses).fill(0);
    for(let i = 0; i < array.length; ++i){
        counts[array[i]] += 1 / array.length;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].rowVector(counts);
}
function giniImpurity(array) {
    if (array.length === 0) {
        return 0;
    }
    let probabilities = toDiscreteDistribution(array, getNumberOfClasses(array)).getRow(0);
    let sum = 0.0;
    for(let i = 0; i < probabilities.length; ++i){
        sum += probabilities[i] * probabilities[i];
    }
    return 1 - sum;
}
function getNumberOfClasses(array) {
    return array.filter((val, i, arr)=>{
        return arr.indexOf(val) === i;
    }).map((val)=>val + 1).reduce((a, b)=>Math.max(a, b));
}
function giniGain(array, splitted) {
    let splitsImpurity = 0.0;
    let splits = [
        'greater',
        'lesser'
    ];
    for(let i = 0; i < splits.length; ++i){
        let currentSplit = splitted[splits[i]];
        splitsImpurity += giniImpurity(currentSplit) * currentSplit.length / array.length;
    }
    return giniImpurity(array) - splitsImpurity;
}
function squaredError(array) {
    let l = array.length;
    if (l === 0) {
        return 0.0;
    }
    let m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(array);
    let error = 0.0;
    for(let i = 0; i < l; ++i){
        let currentElement = array[i];
        error += (currentElement - m) * (currentElement - m);
    }
    return error;
}
function regressionError(array, splitted) {
    let error = 0.0;
    let splits = [
        'greater',
        'lesser'
    ];
    for(let i = 0; i < splits.length; ++i){
        let currentSplit = splitted[splits[i]];
        error += squaredError(currentSplit);
    }
    return error;
}
function matrixSplitter(X, y, column, value) {
    let lesserX = [];
    let greaterX = [];
    let lesserY = [];
    let greaterY = [];
    for(let i = 0; i < X.rows; ++i){
        if (X.get(i, column) < value) {
            lesserX.push(X.getRow(i));
            lesserY.push(y[i]);
        } else {
            greaterX.push(X.getRow(i));
            greaterY.push(y[i]);
        }
    }
    return {
        greaterX: greaterX,
        greaterY: greaterY,
        lesserX: lesserX,
        lesserY: lesserY
    };
}
function mean(a, b) {
    return (a + b) / 2;
}
function zip(a, b) {
    if (a.length !== b.length) {
        throw new TypeError(`Error on zip: the size of a: ${a.length} is different from b: ${b.length}`);
    }
    let ret = new Array(a.length);
    for(let i = 0; i < a.length; ++i){
        ret[i] = [
            a[i],
            b[i]
        ];
    }
    return ret;
}
}}),
"[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>TreeNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/utils.js [app-client] (ecmascript)");
;
;
;
const gainFunctions = {
    gini: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["giniGain"],
    regression: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["regressionError"]
};
const splitFunctions = {
    mean: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mean"]
};
class TreeNode {
    /**
   * @private
   * Constructor for a tree node given the options received on the main classes (DecisionTreeClassifier, DecisionTreeRegression)
   * @param {object|TreeNode} options for loading
   * @constructor
   */ constructor(options){
        // options parameters
        this.kind = options.kind;
        this.gainFunction = options.gainFunction;
        this.splitFunction = options.splitFunction;
        this.minNumSamples = options.minNumSamples;
        this.maxDepth = options.maxDepth;
        this.gainThreshold = options.gainThreshold || 0;
    }
    /**
   * @private
   * Function that retrieve the best feature to make the split.
   * @param {Matrix} XTranspose - Training set transposed
   * @param {Array} y - labels or values (depending of the decision tree)
   * @return {object} - return tree values, the best gain, column and the split value.
   */ bestSplit(XTranspose, y) {
        // Depending in the node tree class, we set the variables to check information gain (to classify)
        // or error (for regression)
        let bestGain = this.kind === 'classifier' ? -Infinity : Infinity;
        let check = this.kind === 'classifier' ? (a, b)=>a > b : (a, b)=>a < b;
        let maxColumn;
        let maxValue;
        let numberSamples;
        for(let i = 0; i < XTranspose.rows; ++i){
            let currentFeature = XTranspose.getRow(i);
            let splitValues = this.featureSplit(currentFeature, y);
            for(let j = 0; j < splitValues.length; ++j){
                let currentSplitVal = splitValues[j];
                let splitted = this.split(currentFeature, y, currentSplitVal);
                let gain = gainFunctions[this.gainFunction](y, splitted);
                if (check(gain, bestGain)) {
                    maxColumn = i;
                    maxValue = currentSplitVal;
                    bestGain = gain;
                    numberSamples = currentFeature.length;
                }
            }
        }
        return {
            maxGain: bestGain,
            maxColumn: maxColumn,
            maxValue: maxValue,
            numberSamples: numberSamples
        };
    }
    /**
   * @private
   * Makes the split of the training labels or values from the training set feature given a split value.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @param {number} splitValue
   * @return {object}
   */ split(x, y, splitValue) {
        let lesser = [];
        let greater = [];
        for(let i = 0; i < x.length; ++i){
            if (x[i] < splitValue) {
                lesser.push(y[i]);
            } else {
                greater.push(y[i]);
            }
        }
        return {
            greater: greater,
            lesser: lesser
        };
    }
    /**
   * @private
   * Calculates the possible points to split over the tree given a training set feature and corresponding labels or values.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @return {Array} possible split values.
   */ featureSplit(x, y) {
        let splitValues = [];
        let arr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zip"])(x, y);
        arr.sort((a, b)=>{
            return a[0] - b[0];
        });
        for(let i = 1; i < arr.length; ++i){
            if (arr[i - 1][1] !== arr[i][1]) {
                splitValues.push(splitFunctions[this.splitFunction](arr[i - 1][0], arr[i][0]));
            }
        }
        return splitValues;
    }
    /**
   * @private
   * Calculate the predictions of a leaf tree node given the training labels or values
   * @param {Array} y
   */ calculatePrediction(y) {
        if (this.kind === 'classifier') {
            this.distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toDiscreteDistribution"])(y, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNumberOfClasses"])(y));
            if (this.distribution.columns === 0) {
                throw new TypeError('Error on calculate the prediction');
            }
        } else {
            this.distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(y);
        }
    }
    /**
   * @private
   * Train a node given the training set and labels, because it trains recursively, it also receive
   * the current depth of the node, parent gain to avoid infinite recursion and boolean value to check if
   * the training set is transposed.
   * @param {Matrix} X - Training set (could be transposed or not given transposed).
   * @param {Array} y - Training labels or values.
   * @param {number} currentDepth - Current depth of the node.
   * @param {number} parentGain - parent node gain or error.
   */ train(X, y, currentDepth, parentGain) {
        if (X.rows <= this.minNumSamples) {
            this.calculatePrediction(y);
            return;
        }
        if (parentGain === undefined) parentGain = 0.0;
        let XTranspose = X.transpose();
        let split = this.bestSplit(XTranspose, y);
        this.splitValue = split.maxValue;
        this.splitColumn = split.maxColumn;
        this.gain = split.maxGain;
        this.numberSamples = split.numberSamples;
        let splittedMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matrixSplitter"])(X, y, this.splitColumn, this.splitValue);
        if (currentDepth < this.maxDepth && this.gain > this.gainThreshold && this.gain !== parentGain && splittedMatrix.lesserX.length > 0 && splittedMatrix.greaterX.length > 0) {
            this.left = new TreeNode(this);
            this.right = new TreeNode(this);
            let lesserX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](splittedMatrix.lesserX);
            let greaterX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](splittedMatrix.greaterX);
            this.left.train(lesserX, splittedMatrix.lesserY, currentDepth + 1, this.gain);
            this.right.train(greaterX, splittedMatrix.greaterY, currentDepth + 1, this.gain);
        } else {
            this.calculatePrediction(y);
        }
    }
    /**
   * @private
   * Calculates the prediction of a given element.
   * @param {Array} row
   * @return {number|Array} prediction
   *          * if a node is a classifier returns an array of probabilities of each class.
   *          * if a node is for regression returns a number with the prediction.
   */ classify(row) {
        if (this.right && this.left) {
            if (row[this.splitColumn] < this.splitValue) {
                return this.left.classify(row);
            } else {
                return this.right.classify(row);
            }
        }
        return this.distribution;
    }
    /**
   * @private
   * Set the parameter of the current node and their children.
   * @param {object} node - parameters of the current node and the children.
   */ setNodeParameters(node) {
        if (node.distribution !== undefined) {
            this.distribution = node.distribution.constructor === Array ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](node.distribution) : node.distribution;
        } else {
            this.distribution = undefined;
            this.splitValue = node.splitValue;
            this.splitColumn = node.splitColumn;
            this.gain = node.gain;
            this.left = new TreeNode(this);
            this.right = new TreeNode(this);
            if (node.left !== {}) {
                this.left.setNodeParameters(node.left);
            }
            if (node.right !== {}) {
                this.right.setNodeParameters(node.right);
            }
        }
    }
}
}}),
"[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DecisionTreeClassifier": (()=>DecisionTreeClassifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    gainFunction: 'gini',
    splitFunction: 'mean',
    minNumSamples: 3,
    maxDepth: Infinity,
    gainThreshold: 0.01
};
class DecisionTreeClassifier {
    /**
   * Create new Decision Tree Classifier with CART implementation with the given options
   * @param {object} options
   * @param {string} [options.gainFunction="gini"] - gain function to get the best split, "gini" the only one supported.
   * @param {string} [options.splitFunction="mean"] - given two integers from a split feature, get the value to split, "mean" the only one supported.
   * @param {number} [options.minNumSamples=3] - minimum number of samples to create a leaf node to decide a class.
   * @param {number} [options.maxDepth=Infinity] - Max depth of the tree.
   * @param {object} model - for load purposes.
   * @constructor
   */ constructor(options, model){
        if (options === true) {
            this.options = model.options;
            this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.options);
            this.root.setNodeParameters(model.root);
        } else {
            this.options = Object.assign({}, defaultOptions, options);
            this.options.kind = 'classifier';
        }
    }
    /**
   * Train the decision tree with the given training set and labels.
   * @param {Matrix|MatrixTransposeView|Array} trainingSet
   * @param {Array} trainingLabels
   */ train(trainingSet, trainingLabels) {
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.options);
        trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        this.root.train(trainingSet, trainingLabels, 0, null);
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|MatrixTransposeView|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        let predictions = new Array(toPredict.rows);
        for(let i = 0; i < toPredict.rows; ++i){
            predictions[i] = this.root.classify(toPredict.getRow(i)).maxRowIndex(0)[1];
        }
        return predictions;
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            options: this.options,
            root: this.root,
            name: 'DTClassifier'
        };
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {DecisionTreeClassifier}
   */ static load(model) {
        if (model.name !== 'DTClassifier') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new DecisionTreeClassifier(true, model);
    }
}
}}),
"[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DecisionTreeRegression": (()=>DecisionTreeRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    gainFunction: 'regression',
    splitFunction: 'mean',
    minNumSamples: 3,
    maxDepth: Infinity
};
class DecisionTreeRegression {
    /**
   * Create new Decision Tree Regression with CART implementation with the given options.
   * @param {object} options
   * @param {string} [options.gainFunction="regression"] - gain function to get the best split, "regression" the only one supported.
   * @param {string} [options.splitFunction="mean"] - given two integers from a split feature, get the value to split, "mean" the only one supported.
   * @param {number} [options.minNumSamples=3] - minimum number of samples to create a leaf node to decide a class.
   * @param {number} [options.maxDepth=Infinity] - Max depth of the tree.
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            this.options = model.options;
            this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.options);
            this.root.setNodeParameters(model.root);
        } else {
            this.options = Object.assign({}, defaultOptions, options);
            this.options.kind = 'regression';
        }
    }
    /**
   * Train the decision tree with the given training set and values.
   * @param {Matrix|MatrixTransposeView|Array} trainingSet
   * @param {Array} trainingValues
   */ train(trainingSet, trainingValues) {
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.options);
        if (typeof trainingSet[0] !== 'undefined' && trainingSet[0].length === undefined) {
            trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].columnVector(trainingSet);
        } else {
            trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        }
        this.root.train(trainingSet, trainingValues, 0);
    }
    /**
   * Predicts the values given the matrix to predict.
   * @param {Matrix|MatrixTransposeView|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        if (typeof toPredict[0] !== 'undefined' && toPredict[0].length === undefined) {
            toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].columnVector(toPredict);
        }
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        let predictions = new Array(toPredict.rows);
        for(let i = 0; i < toPredict.rows; ++i){
            predictions[i] = this.root.classify(toPredict.getRow(i));
        }
        return predictions;
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            options: this.options,
            root: this.root,
            name: 'DTRegression'
        };
    }
    /**
   * Load a Decision tree regression with the given model.
   * @param {object} model
   * @return {DecisionTreeRegression}
   */ static load(model) {
        if (model.name !== 'DTRegression') {
            throw new RangeError(`Invalid model:${model.name}`);
        }
        return new DecisionTreeRegression(true, model);
    }
}
}}),
"[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
}}),
"[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/ml-array-mode/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>mode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function mode(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var maxValue = 0;
    var maxCount = 0;
    var count = 0;
    var counts = {};
    for(var i = 0; i < input.length; ++i){
        var element = input[i];
        count = counts[element];
        if (count) {
            counts[element]++;
            count++;
        } else {
            counts[element] = count = 1;
        }
        if (count > maxCount) {
            maxCount = count;
            maxValue = input[i];
        }
    }
    return maxValue;
}
;
}}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}}),
"[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/ var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true){
        switch(enc){
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried) return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
}}),
"[project]/node_modules/random-js/dist/random-js.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MersenneTwister19937": (()=>MersenneTwister19937),
    "Random": (()=>Random),
    "bool": (()=>bool),
    "browserCrypto": (()=>browserCrypto),
    "createEntropy": (()=>createEntropy),
    "date": (()=>date),
    "dice": (()=>dice),
    "die": (()=>die),
    "hex": (()=>hex),
    "int32": (()=>int32),
    "int53": (()=>int53),
    "int53Full": (()=>int53Full),
    "integer": (()=>integer),
    "nativeMath": (()=>nativeMath),
    "nodeCrypto": (()=>nodeCrypto),
    "pick": (()=>pick),
    "picker": (()=>picker),
    "real": (()=>real),
    "realZeroToOneExclusive": (()=>realZeroToOneExclusive),
    "realZeroToOneInclusive": (()=>realZeroToOneInclusive),
    "sample": (()=>sample),
    "shuffle": (()=>shuffle),
    "string": (()=>string),
    "uint32": (()=>uint32),
    "uint53": (()=>uint53),
    "uint53Full": (()=>uint53Full),
    "uuid4": (()=>uuid4)
});
const SMALLEST_UNSAFE_INTEGER = 0x20000000000000;
const LARGEST_SAFE_INTEGER = SMALLEST_UNSAFE_INTEGER - 1;
const UINT32_MAX = -1 >>> 0;
const UINT32_SIZE = UINT32_MAX + 1;
const INT32_SIZE = UINT32_SIZE / 2;
const INT32_MAX = INT32_SIZE - 1;
const UINT21_SIZE = 1 << 21;
const UINT21_MAX = UINT21_SIZE - 1;
/**
 * Returns a value within [-0x80000000, 0x7fffffff]
 */ function int32(engine) {
    return engine.next() | 0;
}
function add(distribution, addend) {
    if (addend === 0) {
        return distribution;
    } else {
        return (engine)=>distribution(engine) + addend;
    }
}
/**
 * Returns a value within [-0x20000000000000, 0x1fffffffffffff]
 */ function int53(engine) {
    const high = engine.next() | 0;
    const low = engine.next() >>> 0;
    return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
}
/**
 * Returns a value within [-0x20000000000000, 0x20000000000000]
 */ function int53Full(engine) {
    while(true){
        const high = engine.next() | 0;
        if (high & 0x400000) {
            if ((high & 0x7fffff) === 0x400000 && (engine.next() | 0) === 0) {
                return SMALLEST_UNSAFE_INTEGER;
            }
        } else {
            const low = engine.next() >>> 0;
            return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
        }
    }
}
/**
 * Returns a value within [0, 0xffffffff]
 */ function uint32(engine) {
    return engine.next() >>> 0;
}
/**
 * Returns a value within [0, 0x1fffffffffffff]
 */ function uint53(engine) {
    const high = engine.next() & UINT21_MAX;
    const low = engine.next() >>> 0;
    return high * UINT32_SIZE + low;
}
/**
 * Returns a value within [0, 0x20000000000000]
 */ function uint53Full(engine) {
    while(true){
        const high = engine.next() | 0;
        if (high & UINT21_SIZE) {
            if ((high & UINT21_MAX) === 0 && (engine.next() | 0) === 0) {
                return SMALLEST_UNSAFE_INTEGER;
            }
        } else {
            const low = engine.next() >>> 0;
            return (high & UINT21_MAX) * UINT32_SIZE + low;
        }
    }
}
function isPowerOfTwoMinusOne(value) {
    return (value + 1 & value) === 0;
}
function bitmask(masking) {
    return (engine)=>engine.next() & masking;
}
function downscaleToLoopCheckedRange(range) {
    const extendedRange = range + 1;
    const maximum = extendedRange * Math.floor(UINT32_SIZE / extendedRange);
    return (engine)=>{
        let value = 0;
        do {
            value = engine.next() >>> 0;
        }while (value >= maximum)
        return value % extendedRange;
    };
}
function downscaleToRange(range) {
    if (isPowerOfTwoMinusOne(range)) {
        return bitmask(range);
    } else {
        return downscaleToLoopCheckedRange(range);
    }
}
function isEvenlyDivisibleByMaxInt32(value) {
    return (value | 0) === 0;
}
function upscaleWithHighMasking(masking) {
    return (engine)=>{
        const high = engine.next() & masking;
        const low = engine.next() >>> 0;
        return high * UINT32_SIZE + low;
    };
}
function upscaleToLoopCheckedRange(extendedRange) {
    const maximum = extendedRange * Math.floor(SMALLEST_UNSAFE_INTEGER / extendedRange);
    return (engine)=>{
        let ret = 0;
        do {
            const high = engine.next() & UINT21_MAX;
            const low = engine.next() >>> 0;
            ret = high * UINT32_SIZE + low;
        }while (ret >= maximum)
        return ret % extendedRange;
    };
}
function upscaleWithinU53(range) {
    const extendedRange = range + 1;
    if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
        const highRange = (extendedRange / UINT32_SIZE | 0) - 1;
        if (isPowerOfTwoMinusOne(highRange)) {
            return upscaleWithHighMasking(highRange);
        }
    }
    return upscaleToLoopCheckedRange(extendedRange);
}
function upscaleWithinI53AndLoopCheck(min, max) {
    return (engine)=>{
        let ret = 0;
        do {
            const high = engine.next() | 0;
            const low = engine.next() >>> 0;
            ret = (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
        }while (ret < min || ret > max)
        return ret;
    };
}
/**
 * Returns a Distribution to return a value within [min, max]
 * @param min The minimum integer value, inclusive. No less than -0x20000000000000.
 * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.
 */ function integer(min, max) {
    min = Math.floor(min);
    max = Math.floor(max);
    if (min < -SMALLEST_UNSAFE_INTEGER || !isFinite(min)) {
        throw new RangeError(`Expected min to be at least ${-SMALLEST_UNSAFE_INTEGER}`);
    } else if (max > SMALLEST_UNSAFE_INTEGER || !isFinite(max)) {
        throw new RangeError(`Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`);
    }
    const range = max - min;
    if (range <= 0 || !isFinite(range)) {
        return ()=>min;
    } else if (range === UINT32_MAX) {
        if (min === 0) {
            return uint32;
        } else {
            return add(int32, min + INT32_SIZE);
        }
    } else if (range < UINT32_MAX) {
        return add(downscaleToRange(range), min);
    } else if (range === LARGEST_SAFE_INTEGER) {
        return add(uint53, min);
    } else if (range < LARGEST_SAFE_INTEGER) {
        return add(upscaleWithinU53(range), min);
    } else if (max - 1 - min === LARGEST_SAFE_INTEGER) {
        return add(uint53Full, min);
    } else if (min === -SMALLEST_UNSAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {
        return int53Full;
    } else if (min === -SMALLEST_UNSAFE_INTEGER && max === LARGEST_SAFE_INTEGER) {
        return int53;
    } else if (min === -LARGEST_SAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {
        return add(int53, 1);
    } else if (max === SMALLEST_UNSAFE_INTEGER) {
        return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);
    } else {
        return upscaleWithinI53AndLoopCheck(min, max);
    }
}
function isLeastBitTrue(engine) {
    return (engine.next() & 1) === 1;
}
function lessThan(distribution, value) {
    return (engine)=>distribution(engine) < value;
}
function probability(percentage) {
    if (percentage <= 0) {
        return ()=>false;
    } else if (percentage >= 1) {
        return ()=>true;
    } else {
        const scaled = percentage * UINT32_SIZE;
        if (scaled % 1 === 0) {
            return lessThan(int32, scaled - INT32_SIZE | 0);
        } else {
            return lessThan(uint53, Math.round(percentage * SMALLEST_UNSAFE_INTEGER));
        }
    }
}
function bool(numerator, denominator) {
    if (denominator == null) {
        if (numerator == null) {
            return isLeastBitTrue;
        }
        return probability(numerator);
    } else {
        if (numerator <= 0) {
            return ()=>false;
        } else if (numerator >= denominator) {
            return ()=>true;
        }
        return lessThan(integer(0, denominator - 1), numerator);
    }
}
/**
 * Returns a Distribution that returns a random `Date` within the inclusive
 * range of [`start`, `end`].
 * @param start The minimum `Date`
 * @param end The maximum `Date`
 */ function date(start, end) {
    const distribution = integer(+start, +end);
    return (engine)=>new Date(distribution(engine));
}
/**
 * Returns a Distribution to return a value within [1, sideCount]
 * @param sideCount The number of sides of the die
 */ function die(sideCount) {
    return integer(1, sideCount);
}
/**
 * Returns a distribution that returns an array of length `dieCount` of values
 * within [1, `sideCount`]
 * @param sideCount The number of sides of each die
 * @param dieCount The number of dice
 */ function dice(sideCount, dieCount) {
    const distribution = die(sideCount);
    return (engine)=>{
        const result = [];
        for(let i = 0; i < dieCount; ++i){
            result.push(distribution(engine));
        }
        return result;
    };
}
// tslint:disable:unified-signatures
// has 2**x chars, for faster uniform distribution
const DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";
function string(pool = DEFAULT_STRING_POOL) {
    const poolLength = pool.length;
    if (!poolLength) {
        throw new Error("Expected pool not to be an empty string");
    }
    const distribution = integer(0, poolLength - 1);
    return (engine, length)=>{
        let result = "";
        for(let i = 0; i < length; ++i){
            const j = distribution(engine);
            result += pool.charAt(j);
        }
        return result;
    };
}
const LOWER_HEX_POOL = "0123456789abcdef";
const lowerHex = string(LOWER_HEX_POOL);
const upperHex = string(LOWER_HEX_POOL.toUpperCase());
/**
 * Returns a Distribution that returns a random string comprised of numbers
 * or the characters `abcdef` (or `ABCDEF`) of length `length`.
 * @param length Length of the result string
 * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`
 */ function hex(uppercase) {
    if (uppercase) {
        return upperHex;
    } else {
        return lowerHex;
    }
}
function convertSliceArgument(value, length) {
    if (value < 0) {
        return Math.max(value + length, 0);
    } else {
        return Math.min(value, length);
    }
}
function toInteger(value) {
    const num = +value;
    if (num < 0) {
        return Math.ceil(num);
    } else {
        return Math.floor(num);
    }
}
/**
 * Returns a random value within the provided `source` within the sliced
 * bounds of `begin` and `end`.
 * @param source an array of items to pick from
 * @param begin the beginning slice index (defaults to `0`)
 * @param end the ending slice index (defaults to `source.length`)
 */ function pick(engine, source, begin, end) {
    const length = source.length;
    if (length === 0) {
        throw new RangeError("Cannot pick from an empty array");
    }
    const start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
    const finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);
    if (start >= finish) {
        throw new RangeError(`Cannot pick between bounds ${start} and ${finish}`);
    }
    const distribution = integer(start, finish - 1);
    return source[distribution(engine)];
}
function multiply(distribution, multiplier) {
    if (multiplier === 1) {
        return distribution;
    } else if (multiplier === 0) {
        return ()=>0;
    } else {
        return (engine)=>distribution(engine) * multiplier;
    }
}
/**
 * Returns a floating-point value within [0.0, 1.0)
 */ function realZeroToOneExclusive(engine) {
    return uint53(engine) / SMALLEST_UNSAFE_INTEGER;
}
/**
 * Returns a floating-point value within [0.0, 1.0]
 */ function realZeroToOneInclusive(engine) {
    return uint53Full(engine) / SMALLEST_UNSAFE_INTEGER;
}
/**
 * Returns a floating-point value within [min, max) or [min, max]
 * @param min The minimum floating-point value, inclusive.
 * @param max The maximum floating-point value.
 * @param inclusive If true, `max` will be inclusive.
 */ function real(min, max, inclusive = false) {
    if (!isFinite(min)) {
        throw new RangeError("Expected min to be a finite number");
    } else if (!isFinite(max)) {
        throw new RangeError("Expected max to be a finite number");
    }
    return add(multiply(inclusive ? realZeroToOneInclusive : realZeroToOneExclusive, max - min), min);
}
const sliceArray = Array.prototype.slice;
/**
 * Shuffles an array in-place
 * @param engine The Engine to use when choosing random values
 * @param array The array to shuffle
 * @param downTo minimum index to shuffle. Only used internally.
 */ function shuffle(engine, array, downTo = 0) {
    const length = array.length;
    if (length) {
        for(let i = length - 1 >>> 0; i > downTo; --i){
            const distribution = integer(0, i);
            const j = distribution(engine);
            if (i !== j) {
                const tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
            }
        }
    }
    return array;
}
/**
 * From the population array, produce an array with sampleSize elements that
 * are randomly chosen without repeats.
 * @param engine The Engine to use when choosing random values
 * @param population An array that has items to choose a sample from
 * @param sampleSize The size of the result array
 */ function sample(engine, population, sampleSize) {
    if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
        throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
    }
    if (sampleSize === 0) {
        return [];
    }
    const clone = sliceArray.call(population);
    const length = clone.length;
    if (length === sampleSize) {
        return shuffle(engine, clone, 0);
    }
    const tailLength = length - sampleSize;
    return shuffle(engine, clone, tailLength - 1).slice(tailLength);
}
const stringRepeat = (()=>{
    try {
        if ("x".repeat(3) === "xxx") {
            return (pattern, count)=>pattern.repeat(count);
        }
    } catch (_) {
    // nothing to do here
    }
    return (pattern, count)=>{
        let result = "";
        while(count > 0){
            if (count & 1) {
                result += pattern;
            }
            count >>= 1;
            pattern += pattern;
        }
        return result;
    };
})();
function zeroPad(text, zeroCount) {
    return stringRepeat("0", zeroCount - text.length) + text;
}
/**
 * Returns a Universally Unique Identifier Version 4.
 *
 * See http://en.wikipedia.org/wiki/Universally_unique_identifier
 */ function uuid4(engine) {
    const a = engine.next() >>> 0;
    const b = engine.next() | 0;
    const c = engine.next() | 0;
    const d = engine.next() >>> 0;
    return zeroPad(a.toString(16), 8) + "-" + zeroPad((b & 0xffff).toString(16), 4) + "-" + zeroPad((b >> 4 & 0x0fff | 0x4000).toString(16), 4) + "-" + zeroPad((c & 0x3fff | 0x8000).toString(16), 4) + "-" + zeroPad((c >> 4 & 0xffff).toString(16), 4) + zeroPad(d.toString(16), 8);
}
/**
 * An int32-producing Engine that uses `Math.random()`
 */ const nativeMath = {
    next () {
        return Math.random() * UINT32_SIZE | 0;
    }
};
// tslint:disable:unified-signatures
/**
 * A wrapper around an Engine that provides easy-to-use methods for
 * producing values based on known distributions
 */ class Random {
    /**
     * Creates a new Random wrapper
     * @param engine The engine to use (defaults to a `Math.random`-based implementation)
     */ constructor(engine = nativeMath){
        this.engine = engine;
    }
    /**
     * Returns a value within [-0x80000000, 0x7fffffff]
     */ int32() {
        return int32(this.engine);
    }
    /**
     * Returns a value within [0, 0xffffffff]
     */ uint32() {
        return uint32(this.engine);
    }
    /**
     * Returns a value within [0, 0x1fffffffffffff]
     */ uint53() {
        return uint53(this.engine);
    }
    /**
     * Returns a value within [0, 0x20000000000000]
     */ uint53Full() {
        return uint53Full(this.engine);
    }
    /**
     * Returns a value within [-0x20000000000000, 0x1fffffffffffff]
     */ int53() {
        return int53(this.engine);
    }
    /**
     * Returns a value within [-0x20000000000000, 0x20000000000000]
     */ int53Full() {
        return int53Full(this.engine);
    }
    /**
     * Returns a value within [min, max]
     * @param min The minimum integer value, inclusive. No less than -0x20000000000000.
     * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.
     */ integer(min, max) {
        return integer(min, max)(this.engine);
    }
    /**
     * Returns a floating-point value within [0.0, 1.0]
     */ realZeroToOneInclusive() {
        return realZeroToOneInclusive(this.engine);
    }
    /**
     * Returns a floating-point value within [0.0, 1.0)
     */ realZeroToOneExclusive() {
        return realZeroToOneExclusive(this.engine);
    }
    /**
     * Returns a floating-point value within [min, max) or [min, max]
     * @param min The minimum floating-point value, inclusive.
     * @param max The maximum floating-point value.
     * @param inclusive If true, `max` will be inclusive.
     */ real(min, max, inclusive = false) {
        return real(min, max, inclusive)(this.engine);
    }
    bool(numerator, denominator) {
        return bool(numerator, denominator)(this.engine);
    }
    /**
     * Return a random value within the provided `source` within the sliced
     * bounds of `begin` and `end`.
     * @param source an array of items to pick from
     * @param begin the beginning slice index (defaults to `0`)
     * @param end the ending slice index (defaults to `source.length`)
     */ pick(source, begin, end) {
        return pick(this.engine, source, begin, end);
    }
    /**
     * Shuffles an array in-place
     * @param array The array to shuffle
     */ shuffle(array) {
        return shuffle(this.engine, array);
    }
    /**
     * From the population array, returns an array with sampleSize elements that
     * are randomly chosen without repeats.
     * @param population An array that has items to choose a sample from
     * @param sampleSize The size of the result array
     */ sample(population, sampleSize) {
        return sample(this.engine, population, sampleSize);
    }
    /**
     * Returns a value within [1, sideCount]
     * @param sideCount The number of sides of the die
     */ die(sideCount) {
        return die(sideCount)(this.engine);
    }
    /**
     * Returns an array of length `dieCount` of values within [1, sideCount]
     * @param sideCount The number of sides of each die
     * @param dieCount The number of dice
     */ dice(sideCount, dieCount) {
        return dice(sideCount, dieCount)(this.engine);
    }
    /**
     * Returns a Universally Unique Identifier Version 4.
     *
     * See http://en.wikipedia.org/wiki/Universally_unique_identifier
     */ uuid4() {
        return uuid4(this.engine);
    }
    string(length, pool) {
        return string(pool)(this.engine, length);
    }
    /**
     * Returns a random string comprised of numbers or the characters `abcdef`
     * (or `ABCDEF`) of length `length`.
     * @param length Length of the result string
     * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`
     */ hex(length, uppercase) {
        return hex(uppercase)(this.engine, length);
    }
    /**
     * Returns a random `Date` within the inclusive range of [`start`, `end`].
     * @param start The minimum `Date`
     * @param end The maximum `Date`
     */ date(start, end) {
        return date(start, end)(this.engine);
    }
}
/**
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array
 */ const I32Array = (()=>{
    try {
        const buffer = new ArrayBuffer(4);
        const view = new Int32Array(buffer);
        view[0] = INT32_SIZE;
        if (view[0] === -INT32_SIZE) {
            return Int32Array;
        }
    } catch (_) {
    // nothing to do here
    }
    return Array;
})();
let data = null;
const COUNT = 128;
let index = COUNT;
/**
 * An Engine that relies on the globally-available `crypto.getRandomValues`,
 * which is typically available in modern browsers.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 *
 * If unavailable or otherwise non-functioning, then `browserCrypto` will
 * likely `throw` on the first call to `next()`.
 */ const browserCrypto = {
    next () {
        if (index >= COUNT) {
            if (data === null) {
                data = new I32Array(COUNT);
            }
            crypto.getRandomValues(data);
            index = 0;
        }
        return data[index++] | 0;
    }
};
/**
 * Returns an array of random int32 values, based on current time
 * and a random number engine
 *
 * @param engine an Engine to pull random values from, default `nativeMath`
 * @param length the length of the Array, minimum 1, default 16
 */ function createEntropy(engine = nativeMath, length = 16) {
    const array = [];
    array.push(new Date().getTime() | 0);
    for(let i = 1; i < length; ++i){
        array[i] = engine.next() | 0;
    }
    return array;
}
/**
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
 */ const imul = (()=>{
    try {
        if (Math.imul(UINT32_MAX, 5) === -5) {
            return Math.imul;
        }
    } catch (_) {
    // nothing to do here
    }
    const UINT16_MAX = 0xffff;
    return (a, b)=>{
        const ah = a >>> 16 & UINT16_MAX;
        const al = a & UINT16_MAX;
        const bh = b >>> 16 & UINT16_MAX;
        const bl = b & UINT16_MAX;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    };
})();
const ARRAY_SIZE = 624;
const ARRAY_MAX = ARRAY_SIZE - 1;
const M = 397;
const ARRAY_SIZE_MINUS_M = ARRAY_SIZE - M;
const A = 0x9908b0df;
/**
 * An Engine that is a pseudorandom number generator using the Mersenne
 * Twister algorithm based on the prime 2**19937 − 1
 *
 * See http://en.wikipedia.org/wiki/Mersenne_twister
 */ class MersenneTwister19937 {
    /**
     * MersenneTwister19937 should not be instantiated directly.
     * Instead, use the static methods `seed`, `seedWithArray`, or `autoSeed`.
     */ constructor(){
        this.data = new I32Array(ARRAY_SIZE);
        this.index = 0; // integer within [0, 624]
        this.uses = 0;
    }
    /**
     * Returns a MersenneTwister19937 seeded with an initial int32 value
     * @param initial the initial seed value
     */ static seed(initial) {
        return new MersenneTwister19937().seed(initial);
    }
    /**
     * Returns a MersenneTwister19937 seeded with zero or more int32 values
     * @param source A series of int32 values
     */ static seedWithArray(source) {
        return new MersenneTwister19937().seedWithArray(source);
    }
    /**
     * Returns a MersenneTwister19937 seeded with the current time and
     * a series of natively-generated random values
     */ static autoSeed() {
        return MersenneTwister19937.seedWithArray(createEntropy());
    }
    /**
     * Returns the next int32 value of the sequence
     */ next() {
        if ((this.index | 0) >= ARRAY_SIZE) {
            refreshData(this.data);
            this.index = 0;
        }
        const value = this.data[this.index];
        this.index = this.index + 1 | 0;
        this.uses += 1;
        return temper(value) | 0;
    }
    /**
     * Returns the number of times that the Engine has been used.
     *
     * This can be provided to an unused MersenneTwister19937 with the same
     * seed, bringing it to the exact point that was left off.
     */ getUseCount() {
        return this.uses;
    }
    /**
     * Discards one or more items from the engine
     * @param count The count of items to discard
     */ discard(count) {
        if (count <= 0) {
            return this;
        }
        this.uses += count;
        if ((this.index | 0) >= ARRAY_SIZE) {
            refreshData(this.data);
            this.index = 0;
        }
        while(count + this.index > ARRAY_SIZE){
            count -= ARRAY_SIZE - this.index;
            refreshData(this.data);
            this.index = 0;
        }
        this.index = this.index + count | 0;
        return this;
    }
    seed(initial) {
        let previous = 0;
        this.data[0] = previous = initial | 0;
        for(let i = 1; i < ARRAY_SIZE; i = i + 1 | 0){
            this.data[i] = previous = imul(previous ^ previous >>> 30, 0x6c078965) + i | 0;
        }
        this.index = ARRAY_SIZE;
        this.uses = 0;
        return this;
    }
    seedWithArray(source) {
        this.seed(0x012bd6aa);
        seedWithArray(this.data, source);
        return this;
    }
}
function refreshData(data) {
    let k = 0;
    let tmp = 0;
    for(; (k | 0) < ARRAY_SIZE_MINUS_M; k = k + 1 | 0){
        tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
        data[k] = data[k + M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
    }
    for(; (k | 0) < ARRAY_MAX; k = k + 1 | 0){
        tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
        data[k] = data[k - ARRAY_SIZE_MINUS_M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
    }
    tmp = data[ARRAY_MAX] & INT32_SIZE | data[0] & INT32_MAX;
    data[ARRAY_MAX] = data[M - 1] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
}
function temper(value) {
    value ^= value >>> 11;
    value ^= value << 7 & 0x9d2c5680;
    value ^= value << 15 & 0xefc60000;
    return value ^ value >>> 18;
}
function seedWithArray(data, source) {
    let i = 1;
    let j = 0;
    const sourceLength = source.length;
    let k = Math.max(sourceLength, ARRAY_SIZE) | 0;
    let previous = data[0] | 0;
    for(; (k | 0) > 0; --k){
        data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x0019660d)) + (source[j] | 0) + (j | 0) | 0;
        i = i + 1 | 0;
        ++j;
        if ((i | 0) > ARRAY_MAX) {
            data[0] = data[ARRAY_MAX];
            i = 1;
        }
        if (j >= sourceLength) {
            j = 0;
        }
    }
    for(k = ARRAY_MAX; (k | 0) > 0; --k){
        data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x5d588b65)) - i | 0;
        i = i + 1 | 0;
        if ((i | 0) > ARRAY_MAX) {
            data[0] = data[ARRAY_MAX];
            i = 1;
        }
    }
    data[0] = INT32_SIZE;
}
let data$1 = null;
const COUNT$1 = 128;
let index$1 = COUNT$1;
/**
 * An Engine that relies on the node-available
 * `require('crypto').randomBytes`, which has been available since 0.58.
 *
 * See https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback
 *
 * If unavailable or otherwise non-functioning, then `nodeCrypto` will
 * likely `throw` on the first call to `next()`.
 */ const nodeCrypto = {
    next () {
        if (index$1 >= COUNT$1) {
            data$1 = new Int32Array(new Int8Array(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)").randomBytes(4 * COUNT$1)).buffer);
            index$1 = 0;
        }
        return data$1[index$1++] | 0;
    }
};
/**
 * Returns a Distribution to random value within the provided `source`
 * within the sliced bounds of `begin` and `end`.
 * @param source an array of items to pick from
 * @param begin the beginning slice index (defaults to `0`)
 * @param end the ending slice index (defaults to `source.length`)
 */ function picker(source, begin, end) {
    const clone = sliceArray.call(source, begin, end);
    if (clone.length === 0) {
        throw new RangeError(`Cannot pick from a source with no items`);
    }
    const distribution = integer(0, clone.length - 1);
    return (engine)=>clone[distribution(engine)];
}
;
 //# sourceMappingURL=random-js.esm.js.map
}}),
"[project]/node_modules/ml-random-forest/src/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "checkFloat": (()=>checkFloat),
    "collectOOB": (()=>collectOOB),
    "examplesBaggingWithReplacement": (()=>examplesBaggingWithReplacement),
    "featureBagging": (()=>featureBagging),
    "isFloat": (()=>isFloat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/random-js/dist/random-js.esm.js [app-client] (ecmascript)");
;
;
function checkFloat(n) {
    return n > 0.0 && n <= 1.0;
}
function isFloat(n) {
    return Number(n) === n && n % 1 !== 0;
}
function examplesBaggingWithReplacement(trainingSet, trainingValue, seed) {
    let engine;
    let distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["integer"])(0, trainingSet.rows - 1);
    if (seed === undefined) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].autoSeed();
    } else if (Number.isInteger(seed)) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].seed(seed);
    } else {
        throw new RangeError(`Expected seed must be undefined or integer not ${seed}`);
    }
    let Xr = new Array(trainingSet.rows);
    let yr = new Array(trainingSet.rows);
    let oob = new Array(trainingSet.rows).fill(0);
    let oobN = trainingSet.rows;
    for(let i = 0; i < trainingSet.rows; ++i){
        let index = distribution(engine);
        Xr[i] = trainingSet.getRow(index);
        yr[i] = trainingValue[index];
        if (oob[index]++ === 0) {
            oobN--;
        }
    }
    let Xoob = new Array(oobN);
    let ioob = new Array(oobN);
    // run backwards to have ioob filled in increasing order
    for(let i = trainingSet.rows - 1; i >= 0 && oobN > 0; --i){
        if (oob[i] === 0) {
            Xoob[--oobN] = trainingSet.getRow(i);
            ioob[oobN] = i;
        }
    }
    return {
        X: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](Xr),
        y: yr,
        Xoob: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](Xoob),
        ioob,
        seed: engine.next()
    };
}
function featureBagging(trainingSet, n, replacement, seed) {
    if (trainingSet.columns < n) {
        throw new RangeError('N should be less or equal to the number of columns of X');
    }
    let distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["integer"])(0, trainingSet.columns - 1);
    let engine;
    if (seed === undefined) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].autoSeed();
    } else if (Number.isInteger(seed)) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].seed(seed);
    } else {
        throw new RangeError(`Expected seed must be undefined or integer not ${seed}`);
    }
    let toRet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](trainingSet.rows, n);
    let usedIndex;
    let index;
    if (replacement) {
        usedIndex = new Array(n);
        for(let i = 0; i < n; ++i){
            index = distribution(engine);
            usedIndex[i] = index;
            toRet.setColumn(i, trainingSet.getColumn(index));
        }
    } else {
        usedIndex = new Set();
        index = distribution(engine);
        for(let i = 0; i < n; ++i){
            while(usedIndex.has(index)){
                index = distribution(engine);
            }
            toRet.setColumn(i, trainingSet.getColumn(index));
            usedIndex.add(index);
        }
        usedIndex = Array.from(usedIndex);
    }
    return {
        X: toRet,
        usedIndex: usedIndex,
        seed: engine.next()
    };
}
const collectOOB = (oob, y, aggregate)=>{
    const res = Array(y.length);
    for(let i = 0; i < y.length; i++){
        const all = [];
        for(let j = 0; j < oob.length; j++){
            const o = oob[j];
            if (o.index[0] === i) {
                all.push(o.predicted[0]);
                o.index = o.index.slice(1);
                o.predicted = o.predicted.slice(1);
            }
        }
        res[i] = {
            true: y[i],
            all: all,
            predicted: aggregate(all)
        };
    }
    return res;
};
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestBase": (()=>RandomForestBase)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/utils.js [app-client] (ecmascript)");
;
;
;
class RandomForestBase {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number|String} [options.maxFeatures] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement] - use replacement over the sample features.
   * @param {number} [options.seed] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators] - number of estimator to use.
   * @param {object} [options.treeOptions] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {boolean} [options.isClassifier] - boolean to check if is a classifier or regression model (used by subclasses).
   * @param {boolean} [options.useSampleBagging] - use bagging over training samples.
   * @param {boolean} [options.noOOB] - don't calculate Out-Of-Bag predictions.
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            this.replacement = model.replacement;
            this.maxFeatures = model.maxFeatures;
            this.nEstimators = model.nEstimators;
            this.treeOptions = model.treeOptions;
            this.isClassifier = model.isClassifier;
            this.seed = model.seed;
            this.n = model.n;
            this.indexes = model.indexes;
            this.useSampleBagging = model.useSampleBagging;
            this.noOOB = true;
            this.maxSamples = model.maxSamples;
            let Estimator = this.isClassifier ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeClassifier"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeRegression"];
            this.estimators = model.estimators.map((est)=>Estimator.load(est));
        } else {
            this.replacement = options.replacement;
            this.maxFeatures = options.maxFeatures;
            this.nEstimators = options.nEstimators;
            this.treeOptions = options.treeOptions;
            this.isClassifier = options.isClassifier;
            this.seed = options.seed;
            this.useSampleBagging = options.useSampleBagging;
            this.noOOB = options.noOOB;
            this.maxSamples = options.maxSamples;
        }
    }
    /**
   * Train the decision tree with the given training set and labels.
   * @param {Matrix|Array} trainingSet
   * @param {Array} trainingValues
   */ train(trainingSet, trainingValues) {
        let currentSeed = this.seed;
        trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        this.maxFeatures = this.maxFeatures || trainingSet.columns;
        this.numberFeatures = trainingSet.columns;
        this.numberSamples = trainingSet.rows;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkFloat"])(this.maxFeatures)) {
            this.n = Math.floor(trainingSet.columns * this.maxFeatures);
        } else if (Number.isInteger(this.maxFeatures)) {
            if (this.maxFeatures > trainingSet.columns) {
                throw new RangeError(`The maxFeatures parameter should be less than ${trainingSet.columns}`);
            } else {
                this.n = this.maxFeatures;
            }
        } else {
            throw new RangeError(`Cannot process the maxFeatures parameter ${this.maxFeatures}`);
        }
        if (this.maxSamples) {
            if (this.maxSamples < 0) {
                throw new RangeError(`Please choose a positive value for maxSamples`);
            } else {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFloat"])(this.maxSamples)) {
                    if (this.maxSamples > 1.0) {
                        throw new RangeError('Please choose either a float value between 0 and 1 or a positive integer for maxSamples');
                    } else {
                        this.numberSamples = Math.floor(trainingSet.rows * this.maxSamples);
                    }
                } else if (Number.isInteger(this.maxSamples)) {
                    if (this.maxSamples > trainingSet.rows) {
                        throw new RangeError(`The maxSamples parameter should be less than ${trainingSet.rows}`);
                    } else {
                        this.numberSamples = this.maxSamples;
                    }
                }
            }
        }
        if (this.maxSamples) {
            if (trainingSet.rows !== this.numberSamples) {
                let tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](this.numberSamples, trainingSet.columns);
                for(let j = 0; j < this.numberSamples; j++){
                    tmp.removeRow(0);
                }
                for(let i = 0; i < this.numberSamples; i++){
                    tmp.addRow(trainingSet.getRow(i));
                }
                trainingSet = tmp;
                trainingValues = trainingValues.slice(0, this.numberSamples);
            }
        }
        let Estimator;
        if (this.isClassifier) {
            Estimator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeClassifier"];
        } else {
            Estimator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeRegression"];
        }
        this.estimators = new Array(this.nEstimators);
        this.indexes = new Array(this.nEstimators);
        let oobResults = new Array(this.nEstimators);
        for(let i = 0; i < this.nEstimators; ++i){
            let res = this.useSampleBagging ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["examplesBaggingWithReplacement"])(trainingSet, trainingValues, currentSeed) : {
                X: trainingSet,
                y: trainingValues,
                seed: currentSeed,
                Xoob: undefined,
                yoob: [],
                ioob: []
            };
            let X = res.X;
            let y = res.y;
            currentSeed = res.seed;
            let { Xoob, ioob } = res;
            // Other implementations of random forests apply feature bagging at every split during tree generation.
            // So I think it would be better to implement it at the CART level, not here.
            res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureBagging"])(X, this.n, this.replacement, currentSeed);
            X = res.X;
            currentSeed = res.seed;
            this.indexes[i] = res.usedIndex;
            this.estimators[i] = new Estimator(this.treeOptions);
            this.estimators[i].train(X, y);
            if (!this.noOOB && this.useSampleBagging) {
                let xoob = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixColumnSelectionView"](Xoob, this.indexes[i]);
                oobResults[i] = {
                    index: ioob,
                    predicted: this.estimators[i].predict(xoob)
                };
            }
        }
        if (!this.noOOB && this.useSampleBagging && oobResults.length > 0) {
            this.oobResults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectOOB"])(oobResults, trainingValues, this.selection.bind(this));
        }
    }
    /**
   * Evaluate the feature importances for each tree in the ensemble
   * @return {Array} feature importances
   */ featureImportance() {
        const trees = JSON.parse(JSON.stringify(this.estimators));
        const indexes = JSON.parse(JSON.stringify(this.indexes));
        let importance = [];
        function computeFeatureImportances(i, node) {
            // node.gain can be null or undefined
            if (!node || !('splitColumn' in node) || !(node.gain > 0)) return;
            let f = node.gain * node.numberSamples;
            if ('left' in node) {
                f -= (node.left.gain || 0) * (node.left.numberSamples || 0);
            }
            if ('right' in node) {
                f -= (node.right.gain || 0) * (node.right.numberSamples || 0);
            }
            importance[i][node.splitColumn] += f;
            if (node.left) {
                computeFeatureImportances(i, node.left);
            }
            if (node.right) {
                computeFeatureImportances(i, node.right);
            }
        }
        function normalizeImportances(i) {
            const s = importance[i].reduce((cum, v)=>{
                return cum += v;
            }, 0);
            importance[i] = importance[i].map((v)=>{
                return v / s;
            });
        }
        for(let i = 0; i < trees.length; i++){
            importance.push(new Array(this.numberFeatures).fill(0.0));
            computeFeatureImportances(i, trees[i].root);
            normalizeImportances(i);
        }
        let avgImportance = new Array(this.numberFeatures).fill(0.0);
        for(let i = 0; i < importance.length; i++){
            for(let x = 0; x < this.numberFeatures; x++){
                avgImportance[indexes[i][x]] += importance[i][x];
            }
        }
        const s = avgImportance.reduce((cum, v)=>{
            return cum += v;
        }, 0);
        return avgImportance.map((v)=>{
            return v / s;
        });
    }
    /**
   * Method that returns the way the algorithm generates the predictions, for example, in classification
   * you can return the mode of all predictions retrieved by the trees, or in case of regression you can
   * use the mean or the median.
   * @abstract
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction.
   */ // eslint-disable-next-line no-unused-vars
    selection(values) {
        throw new Error("Abstract method 'selection' not implemented!");
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        const predictionValues = this.predictionValues(toPredict);
        let predictions = new Array(predictionValues.rows);
        for(let i = 0; i < predictionValues.rows; ++i){
            predictions[i] = this.selection(predictionValues.getRow(i));
        }
        return predictions;
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @return {MatrixTransposeView} predictions of estimators
   */ predictionValues(toPredict) {
        let predictionValues = new Array(this.nEstimators);
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        for(let i = 0; i < this.nEstimators; ++i){
            let X = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixColumnSelectionView"](toPredict, this.indexes[i]);
            predictionValues[i] = this.estimators[i].predict(X);
        }
        return predictionValues = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixTransposeView"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WrapperMatrix2D"](predictionValues));
    }
    /**
   * Returns the Out-Of-Bag predictions.
   * @return {Array} predictions
   */ predictOOB() {
        if (!this.oobResults || this.oobResults.length === 0) {
            throw new Error('No Out-Of-Bag results found. Did you forgot to train first?');
        }
        return this.oobResults.map((v)=>v.predicted);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            indexes: this.indexes,
            n: this.n,
            replacement: this.replacement,
            maxFeatures: this.maxFeatures,
            nEstimators: this.nEstimators,
            treeOptions: this.treeOptions,
            isClassifier: this.isClassifier,
            seed: this.seed,
            estimators: this.estimators.map((est)=>est.toJSON()),
            useSampleBagging: this.useSampleBagging
        };
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestClassifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestClassifier": (()=>RandomForestClassifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mode$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mode/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    maxFeatures: 1.0,
    replacement: true,
    nEstimators: 50,
    seed: 42,
    useSampleBagging: true,
    noOOB: false
};
class RandomForestClassifier extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomForestBase"] {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number} [options.maxFeatures=1.0] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement=true] - use replacement over the sample features.
   * @param {number} [options.seed=42] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators=50] - number of estimator to use.
   * @param {object} [options.treeOptions={}] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {boolean} [options.useSampleBagging=true] - use bagging over training samples.
   * @param {number} [options.maxSamples=null] - if null, then draw X.shape[0] samples. If int, then draw maxSamples samples. If float, then draw maxSamples * X.shape[0] samples. Thus, maxSamples should be in the interval (0.0, 1.0].
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            super(true, model.baseModel);
        } else {
            options = Object.assign({}, defaultOptions, options);
            options.isClassifier = true;
            super(options);
        }
    }
    /**
   * retrieve the prediction given the selection method.
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction
   */ selection(values) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mode$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        let baseModel = super.toJSON();
        return {
            baseModel: baseModel,
            name: 'RFClassifier'
        };
    }
    /**
   * Returns the confusion matrix
   * Make sure to run train first.
   * @return {object} - Current model.
   */ getConfusionMatrix() {
        if (!this.oobResults) {
            throw new Error('No Out-Of-Bag results available.');
        }
        const labels = new Set();
        const matrix = this.oobResults.reduce((p, v)=>{
            labels.add(v.true);
            labels.add(v.predicted);
            const x = p[v.predicted] || {};
            x[v.true] = (x[v.true] || 0) + 1;
            p[v.predicted] = x;
            return p;
        }, {});
        const sortedLabels = [
            ...labels
        ].sort();
        return sortedLabels.map((v)=>sortedLabels.map((w)=>(matrix[v] || {})[w] || 0));
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {RandomForestClassifier}
   */ static load(model) {
        if (model.name !== 'RFClassifier') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new RandomForestClassifier(true, model);
    }
    /**
   * Predicts the probability of a label given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @param {number} label
   * @return {Array} predictions
   */ predictProbability(toPredict, label) {
        const predictionValues = this.predictionValues(toPredict);
        let predictions = new Array(predictionValues.rows);
        for(let i = 0; i < predictionValues.rows; ++i){
            const pvs = predictionValues.getRow(i);
            const l = pvs.length;
            const roundFactor = Math.pow(10, 6);
            predictions[i] = Math.round(pvs.reduce((p, v)=>{
                if (v === label) {
                    p += roundFactor / l;
                }
                return p;
            })) / roundFactor;
        }
        return predictions;
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestRegression.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestRegression": (()=>RandomForestRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$median$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-median/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)");
;
;
;
const selectionMethods = {
    mean: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    median: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$median$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
};
const defaultOptions = {
    maxFeatures: 1.0,
    replacement: false,
    nEstimators: 50,
    treeOptions: {},
    selectionMethod: 'mean',
    seed: 42,
    useSampleBagging: true,
    noOOB: false
};
class RandomForestRegression extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomForestBase"] {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number} [options.maxFeatures=1.0] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement=true] - use replacement over the sample features.
   * @param {number} [options.seed=42] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators=50] - number of estimator to use.
   * @param {object} [options.treeOptions={}] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {string} [options.selectionMethod="mean"] - the way to calculate the prediction from estimators, "mean" and "median" are supported.
   * @param {boolean} [options.useSampleBagging=true] - use bagging over training samples.
   * @param {number} [options.maxSamples=null] - if null, then draw X.shape[0] samples. If int, then draw maxSamples samples. If float, then draw maxSamples * X.shape[0] samples. Thus, maxSamples should be in the interval (0.0, 1.0].
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            super(true, model.baseModel);
            this.selectionMethod = model.selectionMethod;
        } else {
            options = Object.assign({}, defaultOptions, options);
            if (!(options.selectionMethod === 'mean' || options.selectionMethod === 'median')) {
                throw new RangeError(`Unsupported selection method ${options.selectionMethod}`);
            }
            options.isClassifier = false;
            super(options);
            this.selectionMethod = options.selectionMethod;
        }
    }
    /**
   * retrieve the prediction given the selection method.
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction
   */ selection(values) {
        return selectionMethods[this.selectionMethod](values);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        let baseModel = super.toJSON();
        return {
            baseModel: baseModel,
            selectionMethod: this.selectionMethod,
            name: 'RFRegression'
        };
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {RandomForestRegression}
   */ static load(model) {
        if (model.name !== 'RFRegression') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new RandomForestRegression(true, model);
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
}}),
"[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/median-quickselect/lib/median-quickselect.min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    function a(d) {
        for(var e = 0, f = d.length - 1, g = void 0, h = void 0, i = void 0, j = c(e, f); !0;){
            if (f <= e) return d[j];
            if (f == e + 1) return d[e] > d[f] && b(d, e, f), d[j];
            for(g = c(e, f), d[g] > d[f] && b(d, g, f), d[e] > d[f] && b(d, e, f), d[g] > d[e] && b(d, g, e), b(d, g, e + 1), h = e + 1, i = f; !0;){
                do h++;
                while (d[e] > d[h])
                do i--;
                while (d[i] > d[e])
                if (i < h) break;
                b(d, h, i);
            }
            b(d, e, i), i <= j && (e = h), i >= j && (f = i - 1);
        }
    }
    var b = function b(d, e, f) {
        var _ref;
        return _ref = [
            d[f],
            d[e]
        ], d[e] = _ref[0], d[f] = _ref[1], _ref;
    }, c = function c(d, e) {
        return ~~((d + e) / 2);
    };
    'undefined' != ("TURBOPACK compile-time value", "object") && module.exports ? module.exports = a : window.median = a;
})();
}}),
"[project]/node_modules/ml-array-median/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>median)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$median$2d$quickselect$2f$lib$2f$median$2d$quickselect$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/median-quickselect/lib/median-quickselect.min.js [app-client] (ecmascript)");
;
;
function median(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$median$2d$quickselect$2f$lib$2f$median$2d$quickselect$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input.slice());
}
;
}}),
"[project]/node_modules/papaparse/papaparse.min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* @license
Papa Parse
v5.5.2
https://github.com/mholt/PapaParse
License: MIT
*/ ((e, t)=>{
    "function" == typeof define && define.amd ? ((r)=>r !== undefined && __turbopack_context__.v(r))(t()) : ("TURBOPACK compile-time truthy", 1) ? module.exports = t() : ("TURBOPACK unreachable", undefined);
})(this, function r() {
    var n = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n ? n : {};
    var d, s = !n.document && !!n.postMessage, a = n.IS_PAPA_WORKER || !1, o = {}, h = 0, v = {};
    function u(e) {
        this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
            data: [],
            errors: [],
            meta: {}
        }, (function(e) {
            var t = w(e);
            t.chunkSize = parseInt(t.chunkSize), e.step || e.chunk || (t.chunkSize = null);
            this._handle = new i(t), (this._handle.streamer = this)._config = t;
        }).call(this, e), this.parseChunk = function(t, e) {
            var i = parseInt(this._config.skipFirstNLines) || 0;
            if (this.isFirstChunk && 0 < i) {
                let e = this._config.newline;
                e || (r = this._config.quoteChar || '"', e = this._handle.guessLineEndings(t, r)), t = [
                    ...t.split(e).slice(i)
                ].join(e);
            }
            this.isFirstChunk && U(this._config.beforeFirstChunk) && void 0 !== (r = this._config.beforeFirstChunk(t)) && (t = r), this.isFirstChunk = !1, this._halted = !1;
            var i = this._partialLine + t, r = (this._partialLine = "", this._handle.parse(i, this._baseIndex, !this._finished));
            if (!this._handle.paused() && !this._handle.aborted()) {
                t = r.meta.cursor, i = (this._finished || (this._partialLine = i.substring(t - this._baseIndex), this._baseIndex = t), r && r.data && (this._rowCount += r.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview);
                if (a) n.postMessage({
                    results: r,
                    workerId: v.WORKER_ID,
                    finished: i
                });
                else if (U(this._config.chunk) && !e) {
                    if (this._config.chunk(r, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
                    this._completeResults = r = void 0;
                }
                return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(r.data), this._completeResults.errors = this._completeResults.errors.concat(r.errors), this._completeResults.meta = r.meta), this._completed || !i || !U(this._config.complete) || r && r.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), i || r && r.meta.paused || this._nextChunk(), r;
            }
            this._halted = !0;
        }, this._sendError = function(e) {
            U(this._config.error) ? this._config.error(e) : a && this._config.error && n.postMessage({
                workerId: v.WORKER_ID,
                error: e,
                finished: !1
            });
        };
    }
    function f(e) {
        var r;
        (e = e || {}).chunkSize || (e.chunkSize = v.RemoteChunkSize), u.call(this, e), this._nextChunk = s ? function() {
            this._readChunk(), this._chunkLoaded();
        } : function() {
            this._readChunk();
        }, this.stream = function(e) {
            this._input = e, this._nextChunk();
        }, this._readChunk = function() {
            if (this._finished) this._chunkLoaded();
            else {
                if (r = new XMLHttpRequest, this._config.withCredentials && (r.withCredentials = this._config.withCredentials), s || (r.onload = y(this._chunkLoaded, this), r.onerror = y(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
                    var e, t = this._config.downloadRequestHeaders;
                    for(e in t)r.setRequestHeader(e, t[e]);
                }
                var i;
                this._config.chunkSize && (i = this._start + this._config.chunkSize - 1, r.setRequestHeader("Range", "bytes=" + this._start + "-" + i));
                try {
                    r.send(this._config.downloadRequestBody);
                } catch (e) {
                    this._chunkError(e.message);
                }
                s && 0 === r.status && this._chunkError();
            }
        }, this._chunkLoaded = function() {
            4 === r.readyState && (r.status < 200 || 400 <= r.status ? this._chunkError() : (this._start += this._config.chunkSize || r.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((e)=>null !== (e = e.getResponseHeader("Content-Range")) ? parseInt(e.substring(e.lastIndexOf("/") + 1)) : -1)(r), this.parseChunk(r.responseText)));
        }, this._chunkError = function(e) {
            e = r.statusText || e;
            this._sendError(new Error(e));
        };
    }
    function l(e) {
        (e = e || {}).chunkSize || (e.chunkSize = v.LocalChunkSize), u.call(this, e);
        var i, r, n = "undefined" != typeof FileReader;
        this.stream = function(e) {
            this._input = e, r = e.slice || e.webkitSlice || e.mozSlice, n ? ((i = new FileReader).onload = y(this._chunkLoaded, this), i.onerror = y(this._chunkError, this)) : i = new FileReaderSync, this._nextChunk();
        }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
            var e = this._input, t = (this._config.chunkSize && (t = Math.min(this._start + this._config.chunkSize, this._input.size), e = r.call(e, this._start, t)), i.readAsText(e, this._config.encoding));
            n || this._chunkLoaded({
                target: {
                    result: t
                }
            });
        }, this._chunkLoaded = function(e) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e.target.result);
        }, this._chunkError = function() {
            this._sendError(i.error);
        };
    }
    function c(e) {
        var i;
        u.call(this, e = e || {}), this.stream = function(e) {
            return i = e, this._nextChunk();
        }, this._nextChunk = function() {
            var e, t;
            if (!this._finished) return e = this._config.chunkSize, i = e ? (t = i.substring(0, e), i.substring(e)) : (t = i, ""), this._finished = !i, this.parseChunk(t);
        };
    }
    function p(e) {
        u.call(this, e = e || {});
        var t = [], i = !0, r = !1;
        this.pause = function() {
            u.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
            u.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e) {
            this._input = e, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
            r && 1 === t.length && (this._finished = !0);
        }, this._nextChunk = function() {
            this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i = !0;
        }, this._streamData = y(function(e) {
            try {
                t.push("string" == typeof e ? e : e.toString(this._config.encoding)), i && (i = !1, this._checkIsFinished(), this.parseChunk(t.shift()));
            } catch (e) {
                this._streamError(e);
            }
        }, this), this._streamError = y(function(e) {
            this._streamCleanUp(), this._sendError(e);
        }, this), this._streamEnd = y(function() {
            this._streamCleanUp(), r = !0, this._streamData("");
        }, this), this._streamCleanUp = y(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
    }
    function i(m) {
        var n, s, a, t, o = Math.pow(2, 53), h = -o, u = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, d = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, i = this, r = 0, f = 0, l = !1, e = !1, c = [], p = {
            data: [],
            errors: [],
            meta: {}
        };
        function y(e) {
            return "greedy" === m.skipEmptyLines ? "" === e.join("").trim() : 1 === e.length && 0 === e[0].length;
        }
        function g() {
            if (p && a && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + v.DefaultDelimiter + "'"), a = !1), m.skipEmptyLines && (p.data = p.data.filter(function(e) {
                return !y(e);
            })), _()) {
                if (p) if (Array.isArray(p.data[0])) {
                    for(var e = 0; _() && e < p.data.length; e++)p.data[e].forEach(t);
                    p.data.splice(0, 1);
                } else p.data.forEach(t);
                function t(e, t) {
                    U(m.transformHeader) && (e = m.transformHeader(e, t)), c.push(e);
                }
            }
            function i(e, t) {
                for(var i = m.header ? {} : [], r = 0; r < e.length; r++){
                    var n = r, s = e[r], s = ((e, t)=>((e)=>(m.dynamicTypingFunction && void 0 === m.dynamicTyping[e] && (m.dynamicTyping[e] = m.dynamicTypingFunction(e)), !0 === (m.dynamicTyping[e] || m.dynamicTyping)))(e) ? "true" === t || "TRUE" === t || "false" !== t && "FALSE" !== t && (((e)=>{
                            if (u.test(e)) {
                                e = parseFloat(e);
                                if (h < e && e < o) return 1;
                            }
                        })(t) ? parseFloat(t) : d.test(t) ? new Date(t) : "" === t ? null : t) : t)(n = m.header ? r >= c.length ? "__parsed_extra" : c[r] : n, s = m.transform ? m.transform(s, n) : s);
                    "__parsed_extra" === n ? (i[n] = i[n] || [], i[n].push(s)) : i[n] = s;
                }
                return m.header && (r > c.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + c.length + " fields but parsed " + r, f + t) : r < c.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + c.length + " fields but parsed " + r, f + t)), i;
            }
            var r;
            p && (m.header || m.dynamicTyping || m.transform) && (r = 1, !p.data.length || Array.isArray(p.data[0]) ? (p.data = p.data.map(i), r = p.data.length) : p.data = i(p.data, 0), m.header && p.meta && (p.meta.fields = c), f += r);
        }
        function _() {
            return m.header && 0 === c.length;
        }
        function k(e, t, i, r) {
            e = {
                type: e,
                code: t,
                message: i
            };
            void 0 !== r && (e.row = r), p.errors.push(e);
        }
        U(m.step) && (t = m.step, m.step = function(e) {
            p = e, _() ? g() : (g(), 0 !== p.data.length && (r += e.data.length, m.preview && r > m.preview ? s.abort() : (p.data = p.data[0], t(p, i))));
        }), this.parse = function(e, t, i) {
            var r = m.quoteChar || '"', r = (m.newline || (m.newline = this.guessLineEndings(e, r)), a = !1, m.delimiter ? U(m.delimiter) && (m.delimiter = m.delimiter(e), p.meta.delimiter = m.delimiter) : ((r = ((e, t, i, r, n)=>{
                var s, a, o, h;
                n = n || [
                    ",",
                    "\t",
                    "|",
                    ";",
                    v.RECORD_SEP,
                    v.UNIT_SEP
                ];
                for(var u = 0; u < n.length; u++){
                    for(var d, f = n[u], l = 0, c = 0, p = 0, g = (o = void 0, new E({
                        comments: r,
                        delimiter: f,
                        newline: t,
                        preview: 10
                    }).parse(e)), _ = 0; _ < g.data.length; _++)i && y(g.data[_]) ? p++ : (d = g.data[_].length, c += d, void 0 === o ? o = d : 0 < d && (l += Math.abs(d - o), o = d));
                    0 < g.data.length && (c /= g.data.length - p), (void 0 === a || l <= a) && (void 0 === h || h < c) && 1.99 < c && (a = l, s = f, h = c);
                }
                return {
                    successful: !!(m.delimiter = s),
                    bestDelimiter: s
                };
            })(e, m.newline, m.skipEmptyLines, m.comments, m.delimitersToGuess)).successful ? m.delimiter = r.bestDelimiter : (a = !0, m.delimiter = v.DefaultDelimiter), p.meta.delimiter = m.delimiter), w(m));
            return m.preview && m.header && r.preview++, n = e, s = new E(r), p = s.parse(n, t, i), g(), l ? {
                meta: {
                    paused: !0
                }
            } : p || {
                meta: {
                    paused: !1
                }
            };
        }, this.paused = function() {
            return l;
        }, this.pause = function() {
            l = !0, s.abort(), n = U(m.chunk) ? "" : n.substring(s.getCharIndex());
        }, this.resume = function() {
            i.streamer._halted ? (l = !1, i.streamer.parseChunk(n, !0)) : setTimeout(i.resume, 3);
        }, this.aborted = function() {
            return e;
        }, this.abort = function() {
            e = !0, s.abort(), p.meta.aborted = !0, U(m.complete) && m.complete(p), n = "";
        }, this.guessLineEndings = function(e, t) {
            e = e.substring(0, 1048576);
            var t = new RegExp(P(t) + "([^]*?)" + P(t), "gm"), i = (e = e.replace(t, "")).split("\r"), t = e.split("\n"), e = 1 < t.length && t[0].length < i[0].length;
            if (1 === i.length || e) return "\n";
            for(var r = 0, n = 0; n < i.length; n++)"\n" === i[n][0] && r++;
            return r >= i.length / 2 ? "\r\n" : "\r";
        };
    }
    function P(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function E(C) {
        var S = (C = C || {}).delimiter, O = C.newline, x = C.comments, I = C.step, A = C.preview, T = C.fastMode, D = null, L = !1, F = null == C.quoteChar ? '"' : C.quoteChar, j = F;
        if (void 0 !== C.escapeChar && (j = C.escapeChar), ("string" != typeof S || -1 < v.BAD_DELIMITERS.indexOf(S)) && (S = ","), x === S) throw new Error("Comment character same as delimiter");
        !0 === x ? x = "#" : ("string" != typeof x || -1 < v.BAD_DELIMITERS.indexOf(x)) && (x = !1), "\n" !== O && "\r" !== O && "\r\n" !== O && (O = "\n");
        var z = 0, M = !1;
        this.parse = function(i, t, r) {
            if ("string" != typeof i) throw new Error("Input must be a string");
            var n = i.length, e = S.length, s = O.length, a = x.length, o = U(I), h = [], u = [], d = [], f = z = 0;
            if (!i) return b();
            if (T || !1 !== T && -1 === i.indexOf(F)) {
                for(var l = i.split(O), c = 0; c < l.length; c++){
                    if (d = l[c], z += d.length, c !== l.length - 1) z += O.length;
                    else if (r) return b();
                    if (!x || d.substring(0, a) !== x) {
                        if (o) {
                            if (h = [], k(d.split(S)), R(), M) return b();
                        } else k(d.split(S));
                        if (A && A <= c) return h = h.slice(0, A), b(!0);
                    }
                }
                return b();
            }
            for(var p = i.indexOf(S, z), g = i.indexOf(O, z), _ = new RegExp(P(j) + P(F), "g"), m = i.indexOf(F, z);;)if (i[z] === F) for(m = z, z++;;){
                if (-1 === (m = i.indexOf(F, m + 1))) return r || u.push({
                    type: "Quotes",
                    code: "MissingQuotes",
                    message: "Quoted field unterminated",
                    row: h.length,
                    index: z
                }), E();
                if (m === n - 1) return E(i.substring(z, m).replace(_, F));
                if (F === j && i[m + 1] === j) m++;
                else if (F === j || 0 === m || i[m - 1] !== j) {
                    -1 !== p && p < m + 1 && (p = i.indexOf(S, m + 1));
                    var y = v(-1 === (g = -1 !== g && g < m + 1 ? i.indexOf(O, m + 1) : g) ? p : Math.min(p, g));
                    if (i.substr(m + 1 + y, e) === S) {
                        d.push(i.substring(z, m).replace(_, F)), i[z = m + 1 + y + e] !== F && (m = i.indexOf(F, z)), p = i.indexOf(S, z), g = i.indexOf(O, z);
                        break;
                    }
                    y = v(g);
                    if (i.substring(m + 1 + y, m + 1 + y + s) === O) {
                        if (d.push(i.substring(z, m).replace(_, F)), w(m + 1 + y + s), p = i.indexOf(S, z), m = i.indexOf(F, z), o && (R(), M)) return b();
                        if (A && h.length >= A) return b(!0);
                        break;
                    }
                    u.push({
                        type: "Quotes",
                        code: "InvalidQuotes",
                        message: "Trailing quote on quoted field is malformed",
                        row: h.length,
                        index: z
                    }), m++;
                }
            }
            else if (x && 0 === d.length && i.substring(z, z + a) === x) {
                if (-1 === g) return b();
                z = g + s, g = i.indexOf(O, z), p = i.indexOf(S, z);
            } else if (-1 !== p && (p < g || -1 === g)) d.push(i.substring(z, p)), z = p + e, p = i.indexOf(S, z);
            else {
                if (-1 === g) break;
                if (d.push(i.substring(z, g)), w(g + s), o && (R(), M)) return b();
                if (A && h.length >= A) return b(!0);
            }
            return E();
            "TURBOPACK unreachable";
            function k(e) {
                h.push(e), f = z;
            }
            function v(e) {
                var t = 0;
                return t = -1 !== e && (e = i.substring(m + 1, e)) && "" === e.trim() ? e.length : t;
            }
            function E(e) {
                return r || (void 0 === e && (e = i.substring(z)), d.push(e), z = n, k(d), o && R()), b();
            }
            function w(e) {
                z = e, k(d), d = [], g = i.indexOf(O, z);
            }
            function b(e) {
                if (C.header && !t && h.length && !L) {
                    var s = h[0], a = {}, o = new Set(s);
                    let n = !1;
                    for(let r = 0; r < s.length; r++){
                        let i = s[r];
                        if (a[i = U(C.transformHeader) ? C.transformHeader(i, r) : i]) {
                            let e, t = a[i];
                            for(; e = i + "_" + t, t++, o.has(e););
                            o.add(e), s[r] = e, a[i]++, n = !0, (D = null === D ? {} : D)[e] = i;
                        } else a[i] = 1, s[r] = i;
                        o.add(i);
                    }
                    n && console.warn("Duplicate headers found and renamed."), L = !0;
                }
                return {
                    data: h,
                    errors: u,
                    meta: {
                        delimiter: S,
                        linebreak: O,
                        aborted: M,
                        truncated: !!e,
                        cursor: f + (t || 0),
                        renamedHeaders: D
                    }
                };
            }
            function R() {
                I(b()), h = [], u = [];
            }
        }, this.abort = function() {
            M = !0;
        }, this.getCharIndex = function() {
            return z;
        };
    }
    function g(e) {
        var t = e.data, i = o[t.workerId], r = !1;
        if (t.error) i.userError(t.error, t.file);
        else if (t.results && t.results.data) {
            var n = {
                abort: function() {
                    r = !0, _(t.workerId, {
                        data: [],
                        errors: [],
                        meta: {
                            aborted: !0
                        }
                    });
                },
                pause: m,
                resume: m
            };
            if (U(i.userStep)) {
                for(var s = 0; s < t.results.data.length && (i.userStep({
                    data: t.results.data[s],
                    errors: t.results.errors,
                    meta: t.results.meta
                }, n), !r); s++);
                delete t.results;
            } else U(i.userChunk) && (i.userChunk(t.results, n, t.file), delete t.results);
        }
        t.finished && !r && _(t.workerId, t.results);
    }
    function _(e, t) {
        var i = o[e];
        U(i.userComplete) && i.userComplete(t), i.terminate(), delete o[e];
    }
    function m() {
        throw new Error("Not implemented.");
    }
    function w(e) {
        if ("object" != typeof e || null === e) return e;
        var t, i = Array.isArray(e) ? [] : {};
        for(t in e)i[t] = w(e[t]);
        return i;
    }
    function y(e, t) {
        return function() {
            e.apply(t, arguments);
        };
    }
    function U(e) {
        return "function" == typeof e;
    }
    return v.parse = function(e, t) {
        var i = (t = t || {}).dynamicTyping || !1;
        U(i) && (t.dynamicTypingFunction = i, i = {});
        if (t.dynamicTyping = i, t.transform = !!U(t.transform) && t.transform, !t.worker || !v.WORKERS_SUPPORTED) return i = null, v.NODE_STREAM_INPUT, "string" == typeof e ? (e = ((e)=>65279 !== e.charCodeAt(0) ? e : e.slice(1))(e), i = new (t.download ? f : c)(t)) : !0 === e.readable && U(e.read) && U(e.on) ? i = new p(t) : (n.File && e instanceof File || e instanceof Object) && (i = new l(t)), i.stream(e);
        (i = (()=>{
            var e;
            return !!v.WORKERS_SUPPORTED && (e = (()=>{
                var e = n.URL || n.webkitURL || null, t = r.toString();
                return v.BLOB_URL || (v.BLOB_URL = e.createObjectURL(new Blob([
                    "var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ",
                    "(",
                    t,
                    ")();"
                ], {
                    type: "text/javascript"
                })));
            })(), (e = new n.Worker(e)).onmessage = g, e.id = h++, o[e.id] = e);
        })()).userStep = t.step, i.userChunk = t.chunk, i.userComplete = t.complete, i.userError = t.error, t.step = U(t.step), t.chunk = U(t.chunk), t.complete = U(t.complete), t.error = U(t.error), delete t.worker, i.postMessage({
            input: e,
            config: t,
            workerId: i.id
        });
    }, v.unparse = function(e, t) {
        var n = !1, _ = !0, m = ",", y = "\r\n", s = '"', a = s + s, i = !1, r = null, o = !1, h = ((()=>{
            if ("object" == typeof t) {
                if ("string" != typeof t.delimiter || v.BAD_DELIMITERS.filter(function(e) {
                    return -1 !== t.delimiter.indexOf(e);
                }).length || (m = t.delimiter), "boolean" != typeof t.quotes && "function" != typeof t.quotes && !Array.isArray(t.quotes) || (n = t.quotes), "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i = t.skipEmptyLines), "string" == typeof t.newline && (y = t.newline), "string" == typeof t.quoteChar && (s = t.quoteChar), "boolean" == typeof t.header && (_ = t.header), Array.isArray(t.columns)) {
                    if (0 === t.columns.length) throw new Error("Option columns is empty");
                    r = t.columns;
                }
                void 0 !== t.escapeChar && (a = t.escapeChar + s), t.escapeFormulae instanceof RegExp ? o = t.escapeFormulae : "boolean" == typeof t.escapeFormulae && t.escapeFormulae && (o = /^[=+\-@\t\r].*$/);
            }
        })(), new RegExp(P(s), "g"));
        "string" == typeof e && (e = JSON.parse(e));
        if (Array.isArray(e)) {
            if (!e.length || Array.isArray(e[0])) return u(null, e, i);
            if ("object" == typeof e[0]) return u(r || Object.keys(e[0]), e, i);
        } else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [
            e.data
        ])), u(e.fields || [], e.data || [], i);
        throw new Error("Unable to serialize unrecognized input");
        function u(e, t, i) {
            var r = "", n = ("string" == typeof e && (e = JSON.parse(e)), "string" == typeof t && (t = JSON.parse(t)), Array.isArray(e) && 0 < e.length), s = !Array.isArray(t[0]);
            if (n && _) {
                for(var a = 0; a < e.length; a++)0 < a && (r += m), r += k(e[a], a);
                0 < t.length && (r += y);
            }
            for(var o = 0; o < t.length; o++){
                var h = (n ? e : t[o]).length, u = !1, d = n ? 0 === Object.keys(t[o]).length : 0 === t[o].length;
                if (i && !n && (u = "greedy" === i ? "" === t[o].join("").trim() : 1 === t[o].length && 0 === t[o][0].length), "greedy" === i && n) {
                    for(var f = [], l = 0; l < h; l++){
                        var c = s ? e[l] : l;
                        f.push(t[o][c]);
                    }
                    u = "" === f.join("").trim();
                }
                if (!u) {
                    for(var p = 0; p < h; p++){
                        0 < p && !d && (r += m);
                        var g = n && s ? e[p] : p;
                        r += k(t[o][g], p);
                    }
                    o < t.length - 1 && (!i || 0 < h && !d) && (r += y);
                }
            }
            return r;
        }
        function k(e, t) {
            var i, r;
            return null == e ? "" : e.constructor === Date ? JSON.stringify(e).slice(1, 25) : (r = !1, o && "string" == typeof e && o.test(e) && (e = "'" + e, r = !0), i = e.toString().replace(h, a), (r = r || !0 === n || "function" == typeof n && n(e, t) || Array.isArray(n) && n[t] || ((e, t)=>{
                for(var i = 0; i < t.length; i++)if (-1 < e.indexOf(t[i])) return !0;
                return !1;
            })(i, v.BAD_DELIMITERS) || -1 < i.indexOf(m) || " " === i.charAt(0) || " " === i.charAt(i.length - 1)) ? s + i + s : i);
        }
    }, v.RECORD_SEP = String.fromCharCode(30), v.UNIT_SEP = String.fromCharCode(31), v.BYTE_ORDER_MARK = "\ufeff", v.BAD_DELIMITERS = [
        "\r",
        "\n",
        '"',
        v.BYTE_ORDER_MARK
    ], v.WORKERS_SUPPORTED = !s && !!n.Worker, v.NODE_STREAM_INPUT = 1, v.LocalChunkSize = 10485760, v.RemoteChunkSize = 5242880, v.DefaultDelimiter = ",", v.Parser = E, v.ParserHandle = i, v.NetworkStreamer = f, v.FileStreamer = l, v.StringStreamer = c, v.ReadableStreamStreamer = p, n.jQuery && ((d = n.jQuery).fn.parse = function(o) {
        var i = o.config || {}, h = [];
        return this.each(function(e) {
            if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && n.FileReader) || !this.files || 0 === this.files.length) return !0;
            for(var t = 0; t < this.files.length; t++)h.push({
                file: this.files[t],
                inputElem: this,
                instanceConfig: d.extend({}, i)
            });
        }), e(), this;
        "TURBOPACK unreachable";
        function e() {
            if (0 === h.length) U(o.complete) && o.complete();
            else {
                var e, t, i, r, n = h[0];
                if (U(o.before)) {
                    var s = o.before(n.file, n.inputElem);
                    if ("object" == typeof s) {
                        if ("abort" === s.action) return e = "AbortError", t = n.file, i = n.inputElem, r = s.reason, void (U(o.error) && o.error({
                            name: e
                        }, t, i, r));
                        if ("skip" === s.action) return void u();
                        "object" == typeof s.config && (n.instanceConfig = d.extend(n.instanceConfig, s.config));
                    } else if ("skip" === s) return void u();
                }
                var a = n.instanceConfig.complete;
                n.instanceConfig.complete = function(e) {
                    U(a) && a(e, n.file, n.inputElem), u();
                }, v.parse(n.file, n.instanceConfig);
            }
        }
        function u() {
            h.splice(0, 1), e();
        }
    }), a && (n.onmessage = function(e) {
        e = e.data;
        void 0 === v.WORKER_ID && e && (v.WORKER_ID = e.workerId);
        "string" == typeof e.input ? n.postMessage({
            workerId: v.WORKER_ID,
            results: v.parse(e.input, e.config),
            finished: !0
        }) : (n.File && e.input instanceof File || e.input instanceof Object) && (e = v.parse(e.input, e.config)) && n.postMessage({
            workerId: v.WORKER_ID,
            results: e,
            finished: !0
        });
    }), (f.prototype = Object.create(u.prototype)).constructor = f, (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(c.prototype)).constructor = c, (p.prototype = Object.create(u.prototype)).constructor = p, v;
});
}}),
}]);

//# sourceMappingURL=node_modules_3e6e1a33._.js.map