(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_94d6d10e._.js", {

"[project]/node_modules/ml-distance-euclidean/lib-es6/euclidean.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "euclidean": (()=>euclidean),
    "squaredEuclidean": (()=>squaredEuclidean)
});
function squaredEuclidean(p, q) {
    let d = 0;
    for(let i = 0; i < p.length; i++){
        d += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return d;
}
function euclidean(p, q) {
    return Math.sqrt(squaredEuclidean(p, q));
}
}}),
"[project]/node_modules/ml-knn/src/KDTree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * Original code from:
 *
 * k-d Tree JavaScript - V 1.01
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */ __turbopack_context__.s({
    "default": (()=>KDTree)
});
function Node(obj, dimension, parent) {
    this.obj = obj;
    this.left = null;
    this.right = null;
    this.parent = parent;
    this.dimension = dimension;
}
class KDTree {
    constructor(points, metric){
        // If points is not an array, assume we're loading a pre-built tree
        if (!Array.isArray(points)) {
            this.dimensions = points.dimensions;
            this.root = points;
            restoreParent(this.root);
        } else {
            this.dimensions = new Array(points[0].length);
            for(var i = 0; i < this.dimensions.length; i++){
                this.dimensions[i] = i;
            }
            this.root = buildTree(points, 0, null, this.dimensions);
        }
        this.metric = metric;
    }
    // Convert to a JSON serializable structure; this just requires removing
    // the `parent` property
    toJSON() {
        const result = toJSONImpl(this.root, true);
        result.dimensions = this.dimensions;
        return result;
    }
    nearest(point, maxNodes, maxDistance) {
        const metric = this.metric;
        const dimensions = this.dimensions;
        var i;
        const bestNodes = new BinaryHeap(function(e) {
            return -e[1];
        });
        function nearestSearch(node) {
            const dimension = dimensions[node.dimension];
            const ownDistance = metric(point, node.obj);
            const linearPoint = {};
            var bestChild, linearDistance, otherChild, i;
            function saveNode(node, distance) {
                bestNodes.push([
                    node,
                    distance
                ]);
                if (bestNodes.size() > maxNodes) {
                    bestNodes.pop();
                }
            }
            for(i = 0; i < dimensions.length; i += 1){
                if (i === node.dimension) {
                    linearPoint[dimensions[i]] = point[dimensions[i]];
                } else {
                    linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                }
            }
            linearDistance = metric(linearPoint, node.obj);
            if (node.right === null && node.left === null) {
                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                    saveNode(node, ownDistance);
                }
                return;
            }
            if (node.right === null) {
                bestChild = node.left;
            } else if (node.left === null) {
                bestChild = node.right;
            } else {
                if (point[dimension] < node.obj[dimension]) {
                    bestChild = node.left;
                } else {
                    bestChild = node.right;
                }
            }
            nearestSearch(bestChild);
            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                saveNode(node, ownDistance);
            }
            if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                if (bestChild === node.left) {
                    otherChild = node.right;
                } else {
                    otherChild = node.left;
                }
                if (otherChild !== null) {
                    nearestSearch(otherChild);
                }
            }
        }
        if (maxDistance) {
            for(i = 0; i < maxNodes; i += 1){
                bestNodes.push([
                    null,
                    maxDistance
                ]);
            }
        }
        if (this.root) {
            nearestSearch(this.root);
        }
        const result = [];
        for(i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1){
            if (bestNodes.content[i][0]) {
                result.push([
                    bestNodes.content[i][0].obj,
                    bestNodes.content[i][1]
                ]);
            }
        }
        return result;
    }
}
function toJSONImpl(src) {
    const dest = new Node(src.obj, src.dimension, null);
    if (src.left) dest.left = toJSONImpl(src.left);
    if (src.right) dest.right = toJSONImpl(src.right);
    return dest;
}
function buildTree(points, depth, parent, dimensions) {
    const dim = depth % dimensions.length;
    if (points.length === 0) {
        return null;
    }
    if (points.length === 1) {
        return new Node(points[0], dim, parent);
    }
    points.sort((a, b)=>a[dimensions[dim]] - b[dimensions[dim]]);
    const median = Math.floor(points.length / 2);
    const node = new Node(points[median], dim, parent);
    node.left = buildTree(points.slice(0, median), depth + 1, node, dimensions);
    node.right = buildTree(points.slice(median + 1), depth + 1, node, dimensions);
    return node;
}
function restoreParent(root) {
    if (root.left) {
        root.left.parent = root;
        restoreParent(root.left);
    }
    if (root.right) {
        root.right.parent = root;
        restoreParent(root.right);
    }
}
// Binary heap implementation from:
// http://eloquentjavascript.net/appendix2.html
class BinaryHeap {
    constructor(scoreFunction){
        this.content = [];
        this.scoreFunction = scoreFunction;
    }
    push(element) {
        // Add the new element to the end of the array.
        this.content.push(element);
        // Allow it to bubble up.
        this.bubbleUp(this.content.length - 1);
    }
    pop() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it sink down.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
        }
        return result;
    }
    peek() {
        return this.content[0];
    }
    size() {
        return this.content.length;
    }
    bubbleUp(n) {
        // Fetch the element that has to be moved.
        var element = this.content[n];
        // When at 0, an element can not go up any further.
        while(n > 0){
            // Compute the parent element's index, and fetch it.
            const parentN = Math.floor((n + 1) / 2) - 1;
            const parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            } else {
                break;
            }
        }
    }
    sinkDown(n) {
        // Look up the target element and its score.
        var length = this.content.length;
        var element = this.content[n];
        var elemScore = this.scoreFunction(element);
        while(true){
            // Compute the indices of the child elements.
            var child2N = (n + 1) * 2;
            var child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                var child1Score = this.scoreFunction(child1);
                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore) {
                    swap = child1N;
                }
            }
            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N];
                var child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }
            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            } else {
                break;
            }
        }
    }
}
}}),
"[project]/node_modules/ml-knn/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>KNN)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-distance-euclidean/lib-es6/euclidean.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-knn/src/KDTree.js [app-client] (ecmascript)");
;
;
class KNN {
    /**
   * @param {Array} dataset
   * @param {Array} labels
   * @param {object} options
   * @param {number} [options.k=numberOfClasses + 1] - Number of neighbors to classify.
   * @param {function} [options.distance=euclideanDistance] - Distance function that takes two parameters.
   */ constructor(dataset, labels, options = {}){
        if (dataset === true) {
            const model = labels;
            this.kdTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.kdTree, options);
            this.k = model.k;
            this.classes = new Set(model.classes);
            this.isEuclidean = model.isEuclidean;
            return;
        }
        const classes = new Set(labels);
        const { distance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"], k = classes.size + 1 } = options;
        const points = new Array(dataset.length);
        for(var i = 0; i < points.length; ++i){
            points[i] = dataset[i].slice();
        }
        for(i = 0; i < labels.length; ++i){
            points[i].push(labels[i]);
        }
        this.kdTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$knn$2f$src$2f$KDTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](points, distance);
        this.k = k;
        this.classes = classes;
        this.isEuclidean = distance === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"];
    }
    /**
   * Create a new KNN instance with the given model.
   * @param {object} model
   * @param {function} distance=euclideanDistance - distance function must be provided if the model wasn't trained with euclidean distance.
   * @return {KNN}
   */ static load(model, distance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
        if (model.name !== 'KNN') {
            throw new Error(`invalid model: ${model.name}`);
        }
        if (!model.isEuclidean && distance === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
            throw new Error('a custom distance function was used to create the model. Please provide it again');
        }
        if (model.isEuclidean && distance !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$distance$2d$euclidean$2f$lib$2d$es6$2f$euclidean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["euclidean"]) {
            throw new Error('the model was created with the default distance function. Do not load it with another one');
        }
        return new KNN(true, model, distance);
    }
    /**
   * Return a JSON containing the kd-tree model.
   * @return {object} JSON KNN model.
   */ toJSON() {
        return {
            name: 'KNN',
            kdTree: this.kdTree,
            k: this.k,
            classes: Array.from(this.classes),
            isEuclidean: this.isEuclidean
        };
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Array} dataset
   * @return {Array} predictions
   */ predict(dataset) {
        if (Array.isArray(dataset)) {
            if (typeof dataset[0] === 'number') {
                return getSinglePrediction(this, dataset);
            } else if (Array.isArray(dataset[0]) && typeof dataset[0][0] === 'number') {
                const predictions = new Array(dataset.length);
                for(var i = 0; i < dataset.length; i++){
                    predictions[i] = getSinglePrediction(this, dataset[i]);
                }
                return predictions;
            }
        }
        throw new TypeError('dataset to predict must be an array or a matrix');
    }
}
function getSinglePrediction(knn, currentCase) {
    var nearestPoints = knn.kdTree.nearest(currentCase, knn.k);
    var pointsPerClass = {};
    var predictedClass = -1;
    var maxPoints = -1;
    var lastElement = nearestPoints[0][0].length - 1;
    for (var element of knn.classes){
        pointsPerClass[element] = 0;
    }
    for(var i = 0; i < nearestPoints.length; ++i){
        var currentClass = nearestPoints[i][0][lastElement];
        var currentPoints = ++pointsPerClass[currentClass];
        if (currentPoints > maxPoints) {
            predictedClass = currentClass;
            maxPoints = currentPoints;
        }
    }
    return predictedClass;
}
}}),
"[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// eslint-disable-next-line @typescript-eslint/unbound-method
__turbopack_context__.s({
    "isAnyArray": (()=>isAnyArray)
});
const toString = Object.prototype.toString;
function isAnyArray(value) {
    const tag = toString.call(value);
    return tag.endsWith('Array]') && !tag.includes('Big');
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/ml-array-max/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>max)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function max(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
    if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
    }
    if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
    }
    var maxValue = input[fromIndex];
    for(var i = fromIndex + 1; i < toIndex; i++){
        if (input[i] > maxValue) maxValue = input[i];
    }
    return maxValue;
}
;
}}),
"[project]/node_modules/ml-array-min/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>min)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function min(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
    if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
    }
    if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
    }
    var minValue = input[fromIndex];
    for(var i = fromIndex + 1; i < toIndex; i++){
        if (input[i] < minValue) minValue = input[i];
    }
    return minValue;
}
;
}}),
"[project]/node_modules/ml-array-rescale/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>rescale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$max$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-max/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$min$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-min/lib-es6/index.js [app-client] (ecmascript)");
;
;
;
function rescale(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    } else if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var output;
    if (options.output !== undefined) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(options.output)) {
            throw new TypeError('output option must be an array if specified');
        }
        output = options.output;
    } else {
        output = new Array(input.length);
    }
    var currentMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$min$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input);
    var currentMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$max$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input);
    if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
    }
    var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
    if (minValue >= maxValue) {
        throw new RangeError('min option must be smaller than max option');
    }
    var factor = (maxValue - minValue) / (currentMax - currentMin);
    for(var i = 0; i < input.length; i++){
        output[i] = (input[i] - currentMin) * factor + minValue;
    }
    return output;
}
;
}}),
"[project]/node_modules/ml-logistic-regression/src/logreg_2classes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>LogisticRegressionTwoClasses)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
;
class LogisticRegressionTwoClasses {
    constructor(options = {}){
        const { numSteps = 50000, learningRate = 5e-4, weights = null } = options;
        this.numSteps = numSteps;
        this.learningRate = learningRate;
        this.weights = weights ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].checkMatrix(weights) : null;
    }
    train(features, target) {
        let weights = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].zeros(1, features.columns);
        for(let step = 0; step < this.numSteps; step++){
            const scores = features.mmul(weights.transpose());
            const predictions = sigmoid(scores);
            // Update weights with gradient
            const outputErrorSignal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].columnVector(predictions).neg().add(target);
            const gradient = features.transpose().mmul(outputErrorSignal);
            weights = weights.add(gradient.mul(this.learningRate).transpose());
        }
        this.weights = weights;
    }
    testScores(features) {
        const finalData = features.mmul(this.weights.transpose());
        return sigmoid(finalData);
    }
    predict(features) {
        const finalData = features.mmul(this.weights.transpose());
        return sigmoid(finalData).map(Math.round);
    }
    static load(model) {
        return new LogisticRegressionTwoClasses(model);
    }
    toJSON() {
        return {
            numSteps: this.numSteps,
            learningRate: this.learningRate,
            weights: this.weights
        };
    }
}
function sigmoid(scores) {
    scores = scores.to1DArray();
    let result = [];
    for(let i = 0; i < scores.length; i++){
        result.push(1 / (1 + Math.exp(-scores[i])));
    }
    return result;
}
}}),
"[project]/node_modules/ml-logistic-regression/src/logreg.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>LogisticRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-logistic-regression/src/logreg_2classes.js [app-client] (ecmascript)");
;
;
function transformClassesForOneVsAll(Y, oneClass) {
    let y = Y.to1DArray();
    for(let i = 0; i < y.length; i++){
        if (y[i] === oneClass) {
            y[i] = 0;
        } else {
            y[i] = 1;
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].columnVector(y);
}
class LogisticRegression {
    constructor(options = {}){
        const { numSteps = 50000, learningRate = 5e-4, classifiers = [], numberClasses = 0 } = options;
        this.numSteps = numSteps;
        this.learningRate = learningRate;
        this.classifiers = classifiers;
        this.numberClasses = numberClasses;
    }
    train(X, Y) {
        this.numberClasses = new Set(Y.to1DArray()).size;
        this.classifiers = new Array(this.numberClasses);
        // train the classifiers
        for(let i = 0; i < this.numberClasses; i++){
            this.classifiers[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                numSteps: this.numSteps,
                learningRate: this.learningRate
            });
            let y = Y.clone();
            y = transformClassesForOneVsAll(y, i);
            this.classifiers[i].train(X, y);
        }
    }
    predict(Xtest) {
        let resultsOneClass = new Array(this.numberClasses).fill(0);
        let i;
        for(i = 0; i < this.numberClasses; i++){
            resultsOneClass[i] = this.classifiers[i].testScores(Xtest);
        }
        let finalResults = new Array(Xtest.rows).fill(0);
        for(i = 0; i < Xtest.rows; i++){
            let minimum = 100000;
            for(let j = 0; j < this.numberClasses; j++){
                if (resultsOneClass[j][i] < minimum) {
                    minimum = resultsOneClass[j][i];
                    finalResults[i] = j;
                }
            }
        }
        return finalResults;
    }
    static load(model) {
        if (model.name !== 'LogisticRegression') {
            throw new Error(`invalid model: ${model.name}`);
        }
        const newClassifier = new LogisticRegression(model);
        for(let i = 0; i < newClassifier.numberClasses; i++){
            newClassifier.classifiers[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$logistic$2d$regression$2f$src$2f$logreg_2classes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].load(model.classifiers[i]);
        }
        return newClassifier;
    }
    toJSON() {
        return {
            name: 'LogisticRegression',
            numSteps: this.numSteps,
            learningRate: this.learningRate,
            numberClasses: this.numberClasses,
            classifiers: this.classifiers
        };
    }
}
}}),
"[project]/node_modules/ml-array-sum/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>sum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function sum(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var sumValue = 0;
    for(var i = 0; i < input.length; i++){
        sumValue += input[i];
    }
    return sumValue;
}
;
}}),
"[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>mean)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$sum$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-sum/lib-es6/index.js [app-client] (ecmascript)");
;
function mean(input) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$sum$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input) / input.length;
}
;
}}),
"[project]/node_modules/ml-cart/src/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getNumberOfClasses": (()=>getNumberOfClasses),
    "giniGain": (()=>giniGain),
    "giniImpurity": (()=>giniImpurity),
    "matrixSplitter": (()=>matrixSplitter),
    "mean": (()=>mean),
    "regressionError": (()=>regressionError),
    "squaredError": (()=>squaredError),
    "toDiscreteDistribution": (()=>toDiscreteDistribution),
    "zip": (()=>zip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
;
;
function toDiscreteDistribution(array, numberOfClasses) {
    let counts = new Array(numberOfClasses).fill(0);
    for(let i = 0; i < array.length; ++i){
        counts[array[i]] += 1 / array.length;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].rowVector(counts);
}
function giniImpurity(array) {
    if (array.length === 0) {
        return 0;
    }
    let probabilities = toDiscreteDistribution(array, getNumberOfClasses(array)).getRow(0);
    let sum = 0.0;
    for(let i = 0; i < probabilities.length; ++i){
        sum += probabilities[i] * probabilities[i];
    }
    return 1 - sum;
}
function getNumberOfClasses(array) {
    return array.filter((val, i, arr)=>{
        return arr.indexOf(val) === i;
    }).map((val)=>val + 1).reduce((a, b)=>Math.max(a, b));
}
function giniGain(array, splitted) {
    let splitsImpurity = 0.0;
    let splits = [
        'greater',
        'lesser'
    ];
    for(let i = 0; i < splits.length; ++i){
        let currentSplit = splitted[splits[i]];
        splitsImpurity += giniImpurity(currentSplit) * currentSplit.length / array.length;
    }
    return giniImpurity(array) - splitsImpurity;
}
function squaredError(array) {
    let l = array.length;
    if (l === 0) {
        return 0.0;
    }
    let m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(array);
    let error = 0.0;
    for(let i = 0; i < l; ++i){
        let currentElement = array[i];
        error += (currentElement - m) * (currentElement - m);
    }
    return error;
}
function regressionError(array, splitted) {
    let error = 0.0;
    let splits = [
        'greater',
        'lesser'
    ];
    for(let i = 0; i < splits.length; ++i){
        let currentSplit = splitted[splits[i]];
        error += squaredError(currentSplit);
    }
    return error;
}
function matrixSplitter(X, y, column, value) {
    let lesserX = [];
    let greaterX = [];
    let lesserY = [];
    let greaterY = [];
    for(let i = 0; i < X.rows; ++i){
        if (X.get(i, column) < value) {
            lesserX.push(X.getRow(i));
            lesserY.push(y[i]);
        } else {
            greaterX.push(X.getRow(i));
            greaterY.push(y[i]);
        }
    }
    return {
        greaterX: greaterX,
        greaterY: greaterY,
        lesserX: lesserX,
        lesserY: lesserY
    };
}
function mean(a, b) {
    return (a + b) / 2;
}
function zip(a, b) {
    if (a.length !== b.length) {
        throw new TypeError(`Error on zip: the size of a: ${a.length} is different from b: ${b.length}`);
    }
    let ret = new Array(a.length);
    for(let i = 0; i < a.length; ++i){
        ret[i] = [
            a[i],
            b[i]
        ];
    }
    return ret;
}
}}),
"[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>TreeNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/utils.js [app-client] (ecmascript)");
;
;
;
const gainFunctions = {
    gini: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["giniGain"],
    regression: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["regressionError"]
};
const splitFunctions = {
    mean: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mean"]
};
class TreeNode {
    /**
   * @private
   * Constructor for a tree node given the options received on the main classes (DecisionTreeClassifier, DecisionTreeRegression)
   * @param {object|TreeNode} options for loading
   * @constructor
   */ constructor(options){
        // options parameters
        this.kind = options.kind;
        this.gainFunction = options.gainFunction;
        this.splitFunction = options.splitFunction;
        this.minNumSamples = options.minNumSamples;
        this.maxDepth = options.maxDepth;
        this.gainThreshold = options.gainThreshold || 0;
    }
    /**
   * @private
   * Function that retrieve the best feature to make the split.
   * @param {Matrix} XTranspose - Training set transposed
   * @param {Array} y - labels or values (depending of the decision tree)
   * @return {object} - return tree values, the best gain, column and the split value.
   */ bestSplit(XTranspose, y) {
        // Depending in the node tree class, we set the variables to check information gain (to classify)
        // or error (for regression)
        let bestGain = this.kind === 'classifier' ? -Infinity : Infinity;
        let check = this.kind === 'classifier' ? (a, b)=>a > b : (a, b)=>a < b;
        let maxColumn;
        let maxValue;
        let numberSamples;
        for(let i = 0; i < XTranspose.rows; ++i){
            let currentFeature = XTranspose.getRow(i);
            let splitValues = this.featureSplit(currentFeature, y);
            for(let j = 0; j < splitValues.length; ++j){
                let currentSplitVal = splitValues[j];
                let splitted = this.split(currentFeature, y, currentSplitVal);
                let gain = gainFunctions[this.gainFunction](y, splitted);
                if (check(gain, bestGain)) {
                    maxColumn = i;
                    maxValue = currentSplitVal;
                    bestGain = gain;
                    numberSamples = currentFeature.length;
                }
            }
        }
        return {
            maxGain: bestGain,
            maxColumn: maxColumn,
            maxValue: maxValue,
            numberSamples: numberSamples
        };
    }
    /**
   * @private
   * Makes the split of the training labels or values from the training set feature given a split value.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @param {number} splitValue
   * @return {object}
   */ split(x, y, splitValue) {
        let lesser = [];
        let greater = [];
        for(let i = 0; i < x.length; ++i){
            if (x[i] < splitValue) {
                lesser.push(y[i]);
            } else {
                greater.push(y[i]);
            }
        }
        return {
            greater: greater,
            lesser: lesser
        };
    }
    /**
   * @private
   * Calculates the possible points to split over the tree given a training set feature and corresponding labels or values.
   * @param {Array} x - Training set feature
   * @param {Array} y - Training set value or label
   * @return {Array} possible split values.
   */ featureSplit(x, y) {
        let splitValues = [];
        let arr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zip"])(x, y);
        arr.sort((a, b)=>{
            return a[0] - b[0];
        });
        for(let i = 1; i < arr.length; ++i){
            if (arr[i - 1][1] !== arr[i][1]) {
                splitValues.push(splitFunctions[this.splitFunction](arr[i - 1][0], arr[i][0]));
            }
        }
        return splitValues;
    }
    /**
   * @private
   * Calculate the predictions of a leaf tree node given the training labels or values
   * @param {Array} y
   */ calculatePrediction(y) {
        if (this.kind === 'classifier') {
            this.distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toDiscreteDistribution"])(y, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNumberOfClasses"])(y));
            if (this.distribution.columns === 0) {
                throw new TypeError('Error on calculate the prediction');
            }
        } else {
            this.distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(y);
        }
    }
    /**
   * @private
   * Train a node given the training set and labels, because it trains recursively, it also receive
   * the current depth of the node, parent gain to avoid infinite recursion and boolean value to check if
   * the training set is transposed.
   * @param {Matrix} X - Training set (could be transposed or not given transposed).
   * @param {Array} y - Training labels or values.
   * @param {number} currentDepth - Current depth of the node.
   * @param {number} parentGain - parent node gain or error.
   */ train(X, y, currentDepth, parentGain) {
        if (X.rows <= this.minNumSamples) {
            this.calculatePrediction(y);
            return;
        }
        if (parentGain === undefined) parentGain = 0.0;
        let XTranspose = X.transpose();
        let split = this.bestSplit(XTranspose, y);
        this.splitValue = split.maxValue;
        this.splitColumn = split.maxColumn;
        this.gain = split.maxGain;
        this.numberSamples = split.numberSamples;
        let splittedMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matrixSplitter"])(X, y, this.splitColumn, this.splitValue);
        if (currentDepth < this.maxDepth && this.gain > this.gainThreshold && this.gain !== parentGain && splittedMatrix.lesserX.length > 0 && splittedMatrix.greaterX.length > 0) {
            this.left = new TreeNode(this);
            this.right = new TreeNode(this);
            let lesserX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](splittedMatrix.lesserX);
            let greaterX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](splittedMatrix.greaterX);
            this.left.train(lesserX, splittedMatrix.lesserY, currentDepth + 1, this.gain);
            this.right.train(greaterX, splittedMatrix.greaterY, currentDepth + 1, this.gain);
        } else {
            this.calculatePrediction(y);
        }
    }
    /**
   * @private
   * Calculates the prediction of a given element.
   * @param {Array} row
   * @return {number|Array} prediction
   *          * if a node is a classifier returns an array of probabilities of each class.
   *          * if a node is for regression returns a number with the prediction.
   */ classify(row) {
        if (this.right && this.left) {
            if (row[this.splitColumn] < this.splitValue) {
                return this.left.classify(row);
            } else {
                return this.right.classify(row);
            }
        }
        return this.distribution;
    }
    /**
   * @private
   * Set the parameter of the current node and their children.
   * @param {object} node - parameters of the current node and the children.
   */ setNodeParameters(node) {
        if (node.distribution !== undefined) {
            this.distribution = node.distribution.constructor === Array ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](node.distribution) : node.distribution;
        } else {
            this.distribution = undefined;
            this.splitValue = node.splitValue;
            this.splitColumn = node.splitColumn;
            this.gain = node.gain;
            this.left = new TreeNode(this);
            this.right = new TreeNode(this);
            if (node.left !== {}) {
                this.left.setNodeParameters(node.left);
            }
            if (node.right !== {}) {
                this.right.setNodeParameters(node.right);
            }
        }
    }
}
}}),
"[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DecisionTreeClassifier": (()=>DecisionTreeClassifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    gainFunction: 'gini',
    splitFunction: 'mean',
    minNumSamples: 3,
    maxDepth: Infinity,
    gainThreshold: 0.01
};
class DecisionTreeClassifier {
    /**
   * Create new Decision Tree Classifier with CART implementation with the given options
   * @param {object} options
   * @param {string} [options.gainFunction="gini"] - gain function to get the best split, "gini" the only one supported.
   * @param {string} [options.splitFunction="mean"] - given two integers from a split feature, get the value to split, "mean" the only one supported.
   * @param {number} [options.minNumSamples=3] - minimum number of samples to create a leaf node to decide a class.
   * @param {number} [options.maxDepth=Infinity] - Max depth of the tree.
   * @param {object} model - for load purposes.
   * @constructor
   */ constructor(options, model){
        if (options === true) {
            this.options = model.options;
            this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.options);
            this.root.setNodeParameters(model.root);
        } else {
            this.options = Object.assign({}, defaultOptions, options);
            this.options.kind = 'classifier';
        }
    }
    /**
   * Train the decision tree with the given training set and labels.
   * @param {Matrix|MatrixTransposeView|Array} trainingSet
   * @param {Array} trainingLabels
   */ train(trainingSet, trainingLabels) {
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.options);
        trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        this.root.train(trainingSet, trainingLabels, 0, null);
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|MatrixTransposeView|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        let predictions = new Array(toPredict.rows);
        for(let i = 0; i < toPredict.rows; ++i){
            predictions[i] = this.root.classify(toPredict.getRow(i)).maxRowIndex(0)[1];
        }
        return predictions;
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            options: this.options,
            root: this.root,
            name: 'DTClassifier'
        };
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {DecisionTreeClassifier}
   */ static load(model) {
        if (model.name !== 'DTClassifier') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new DecisionTreeClassifier(true, model);
    }
}
}}),
"[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DecisionTreeRegression": (()=>DecisionTreeRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/TreeNode.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    gainFunction: 'regression',
    splitFunction: 'mean',
    minNumSamples: 3,
    maxDepth: Infinity
};
class DecisionTreeRegression {
    /**
   * Create new Decision Tree Regression with CART implementation with the given options.
   * @param {object} options
   * @param {string} [options.gainFunction="regression"] - gain function to get the best split, "regression" the only one supported.
   * @param {string} [options.splitFunction="mean"] - given two integers from a split feature, get the value to split, "mean" the only one supported.
   * @param {number} [options.minNumSamples=3] - minimum number of samples to create a leaf node to decide a class.
   * @param {number} [options.maxDepth=Infinity] - Max depth of the tree.
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            this.options = model.options;
            this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](model.options);
            this.root.setNodeParameters(model.root);
        } else {
            this.options = Object.assign({}, defaultOptions, options);
            this.options.kind = 'regression';
        }
    }
    /**
   * Train the decision tree with the given training set and values.
   * @param {Matrix|MatrixTransposeView|Array} trainingSet
   * @param {Array} trainingValues
   */ train(trainingSet, trainingValues) {
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$TreeNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.options);
        if (typeof trainingSet[0] !== 'undefined' && trainingSet[0].length === undefined) {
            trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].columnVector(trainingSet);
        } else {
            trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        }
        this.root.train(trainingSet, trainingValues, 0);
    }
    /**
   * Predicts the values given the matrix to predict.
   * @param {Matrix|MatrixTransposeView|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        if (typeof toPredict[0] !== 'undefined' && toPredict[0].length === undefined) {
            toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].columnVector(toPredict);
        }
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        let predictions = new Array(toPredict.rows);
        for(let i = 0; i < toPredict.rows; ++i){
            predictions[i] = this.root.classify(toPredict.getRow(i));
        }
        return predictions;
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            options: this.options,
            root: this.root,
            name: 'DTRegression'
        };
    }
    /**
   * Load a Decision tree regression with the given model.
   * @param {object} model
   * @return {DecisionTreeRegression}
   */ static load(model) {
        if (model.name !== 'DTRegression') {
            throw new RangeError(`Invalid model:${model.name}`);
        }
        return new DecisionTreeRegression(true, model);
    }
}
}}),
"[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
}}),
"[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/ml-array-mode/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>mode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
;
function mode(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    var maxValue = 0;
    var maxCount = 0;
    var count = 0;
    var counts = {};
    for(var i = 0; i < input.length; ++i){
        var element = input[i];
        count = counts[element];
        if (count) {
            counts[element]++;
            count++;
        } else {
            counts[element] = count = 1;
        }
        if (count > maxCount) {
            maxCount = count;
            maxValue = input[i];
        }
    }
    return maxValue;
}
;
}}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}}),
"[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/ var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true){
        switch(enc){
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried) return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
}}),
"[project]/node_modules/random-js/dist/random-js.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MersenneTwister19937": (()=>MersenneTwister19937),
    "Random": (()=>Random),
    "bool": (()=>bool),
    "browserCrypto": (()=>browserCrypto),
    "createEntropy": (()=>createEntropy),
    "date": (()=>date),
    "dice": (()=>dice),
    "die": (()=>die),
    "hex": (()=>hex),
    "int32": (()=>int32),
    "int53": (()=>int53),
    "int53Full": (()=>int53Full),
    "integer": (()=>integer),
    "nativeMath": (()=>nativeMath),
    "nodeCrypto": (()=>nodeCrypto),
    "pick": (()=>pick),
    "picker": (()=>picker),
    "real": (()=>real),
    "realZeroToOneExclusive": (()=>realZeroToOneExclusive),
    "realZeroToOneInclusive": (()=>realZeroToOneInclusive),
    "sample": (()=>sample),
    "shuffle": (()=>shuffle),
    "string": (()=>string),
    "uint32": (()=>uint32),
    "uint53": (()=>uint53),
    "uint53Full": (()=>uint53Full),
    "uuid4": (()=>uuid4)
});
const SMALLEST_UNSAFE_INTEGER = 0x20000000000000;
const LARGEST_SAFE_INTEGER = SMALLEST_UNSAFE_INTEGER - 1;
const UINT32_MAX = -1 >>> 0;
const UINT32_SIZE = UINT32_MAX + 1;
const INT32_SIZE = UINT32_SIZE / 2;
const INT32_MAX = INT32_SIZE - 1;
const UINT21_SIZE = 1 << 21;
const UINT21_MAX = UINT21_SIZE - 1;
/**
 * Returns a value within [-0x80000000, 0x7fffffff]
 */ function int32(engine) {
    return engine.next() | 0;
}
function add(distribution, addend) {
    if (addend === 0) {
        return distribution;
    } else {
        return (engine)=>distribution(engine) + addend;
    }
}
/**
 * Returns a value within [-0x20000000000000, 0x1fffffffffffff]
 */ function int53(engine) {
    const high = engine.next() | 0;
    const low = engine.next() >>> 0;
    return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
}
/**
 * Returns a value within [-0x20000000000000, 0x20000000000000]
 */ function int53Full(engine) {
    while(true){
        const high = engine.next() | 0;
        if (high & 0x400000) {
            if ((high & 0x7fffff) === 0x400000 && (engine.next() | 0) === 0) {
                return SMALLEST_UNSAFE_INTEGER;
            }
        } else {
            const low = engine.next() >>> 0;
            return (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
        }
    }
}
/**
 * Returns a value within [0, 0xffffffff]
 */ function uint32(engine) {
    return engine.next() >>> 0;
}
/**
 * Returns a value within [0, 0x1fffffffffffff]
 */ function uint53(engine) {
    const high = engine.next() & UINT21_MAX;
    const low = engine.next() >>> 0;
    return high * UINT32_SIZE + low;
}
/**
 * Returns a value within [0, 0x20000000000000]
 */ function uint53Full(engine) {
    while(true){
        const high = engine.next() | 0;
        if (high & UINT21_SIZE) {
            if ((high & UINT21_MAX) === 0 && (engine.next() | 0) === 0) {
                return SMALLEST_UNSAFE_INTEGER;
            }
        } else {
            const low = engine.next() >>> 0;
            return (high & UINT21_MAX) * UINT32_SIZE + low;
        }
    }
}
function isPowerOfTwoMinusOne(value) {
    return (value + 1 & value) === 0;
}
function bitmask(masking) {
    return (engine)=>engine.next() & masking;
}
function downscaleToLoopCheckedRange(range) {
    const extendedRange = range + 1;
    const maximum = extendedRange * Math.floor(UINT32_SIZE / extendedRange);
    return (engine)=>{
        let value = 0;
        do {
            value = engine.next() >>> 0;
        }while (value >= maximum)
        return value % extendedRange;
    };
}
function downscaleToRange(range) {
    if (isPowerOfTwoMinusOne(range)) {
        return bitmask(range);
    } else {
        return downscaleToLoopCheckedRange(range);
    }
}
function isEvenlyDivisibleByMaxInt32(value) {
    return (value | 0) === 0;
}
function upscaleWithHighMasking(masking) {
    return (engine)=>{
        const high = engine.next() & masking;
        const low = engine.next() >>> 0;
        return high * UINT32_SIZE + low;
    };
}
function upscaleToLoopCheckedRange(extendedRange) {
    const maximum = extendedRange * Math.floor(SMALLEST_UNSAFE_INTEGER / extendedRange);
    return (engine)=>{
        let ret = 0;
        do {
            const high = engine.next() & UINT21_MAX;
            const low = engine.next() >>> 0;
            ret = high * UINT32_SIZE + low;
        }while (ret >= maximum)
        return ret % extendedRange;
    };
}
function upscaleWithinU53(range) {
    const extendedRange = range + 1;
    if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
        const highRange = (extendedRange / UINT32_SIZE | 0) - 1;
        if (isPowerOfTwoMinusOne(highRange)) {
            return upscaleWithHighMasking(highRange);
        }
    }
    return upscaleToLoopCheckedRange(extendedRange);
}
function upscaleWithinI53AndLoopCheck(min, max) {
    return (engine)=>{
        let ret = 0;
        do {
            const high = engine.next() | 0;
            const low = engine.next() >>> 0;
            ret = (high & UINT21_MAX) * UINT32_SIZE + low + (high & UINT21_SIZE ? -SMALLEST_UNSAFE_INTEGER : 0);
        }while (ret < min || ret > max)
        return ret;
    };
}
/**
 * Returns a Distribution to return a value within [min, max]
 * @param min The minimum integer value, inclusive. No less than -0x20000000000000.
 * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.
 */ function integer(min, max) {
    min = Math.floor(min);
    max = Math.floor(max);
    if (min < -SMALLEST_UNSAFE_INTEGER || !isFinite(min)) {
        throw new RangeError(`Expected min to be at least ${-SMALLEST_UNSAFE_INTEGER}`);
    } else if (max > SMALLEST_UNSAFE_INTEGER || !isFinite(max)) {
        throw new RangeError(`Expected max to be at most ${SMALLEST_UNSAFE_INTEGER}`);
    }
    const range = max - min;
    if (range <= 0 || !isFinite(range)) {
        return ()=>min;
    } else if (range === UINT32_MAX) {
        if (min === 0) {
            return uint32;
        } else {
            return add(int32, min + INT32_SIZE);
        }
    } else if (range < UINT32_MAX) {
        return add(downscaleToRange(range), min);
    } else if (range === LARGEST_SAFE_INTEGER) {
        return add(uint53, min);
    } else if (range < LARGEST_SAFE_INTEGER) {
        return add(upscaleWithinU53(range), min);
    } else if (max - 1 - min === LARGEST_SAFE_INTEGER) {
        return add(uint53Full, min);
    } else if (min === -SMALLEST_UNSAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {
        return int53Full;
    } else if (min === -SMALLEST_UNSAFE_INTEGER && max === LARGEST_SAFE_INTEGER) {
        return int53;
    } else if (min === -LARGEST_SAFE_INTEGER && max === SMALLEST_UNSAFE_INTEGER) {
        return add(int53, 1);
    } else if (max === SMALLEST_UNSAFE_INTEGER) {
        return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);
    } else {
        return upscaleWithinI53AndLoopCheck(min, max);
    }
}
function isLeastBitTrue(engine) {
    return (engine.next() & 1) === 1;
}
function lessThan(distribution, value) {
    return (engine)=>distribution(engine) < value;
}
function probability(percentage) {
    if (percentage <= 0) {
        return ()=>false;
    } else if (percentage >= 1) {
        return ()=>true;
    } else {
        const scaled = percentage * UINT32_SIZE;
        if (scaled % 1 === 0) {
            return lessThan(int32, scaled - INT32_SIZE | 0);
        } else {
            return lessThan(uint53, Math.round(percentage * SMALLEST_UNSAFE_INTEGER));
        }
    }
}
function bool(numerator, denominator) {
    if (denominator == null) {
        if (numerator == null) {
            return isLeastBitTrue;
        }
        return probability(numerator);
    } else {
        if (numerator <= 0) {
            return ()=>false;
        } else if (numerator >= denominator) {
            return ()=>true;
        }
        return lessThan(integer(0, denominator - 1), numerator);
    }
}
/**
 * Returns a Distribution that returns a random `Date` within the inclusive
 * range of [`start`, `end`].
 * @param start The minimum `Date`
 * @param end The maximum `Date`
 */ function date(start, end) {
    const distribution = integer(+start, +end);
    return (engine)=>new Date(distribution(engine));
}
/**
 * Returns a Distribution to return a value within [1, sideCount]
 * @param sideCount The number of sides of the die
 */ function die(sideCount) {
    return integer(1, sideCount);
}
/**
 * Returns a distribution that returns an array of length `dieCount` of values
 * within [1, `sideCount`]
 * @param sideCount The number of sides of each die
 * @param dieCount The number of dice
 */ function dice(sideCount, dieCount) {
    const distribution = die(sideCount);
    return (engine)=>{
        const result = [];
        for(let i = 0; i < dieCount; ++i){
            result.push(distribution(engine));
        }
        return result;
    };
}
// tslint:disable:unified-signatures
// has 2**x chars, for faster uniform distribution
const DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";
function string(pool = DEFAULT_STRING_POOL) {
    const poolLength = pool.length;
    if (!poolLength) {
        throw new Error("Expected pool not to be an empty string");
    }
    const distribution = integer(0, poolLength - 1);
    return (engine, length)=>{
        let result = "";
        for(let i = 0; i < length; ++i){
            const j = distribution(engine);
            result += pool.charAt(j);
        }
        return result;
    };
}
const LOWER_HEX_POOL = "0123456789abcdef";
const lowerHex = string(LOWER_HEX_POOL);
const upperHex = string(LOWER_HEX_POOL.toUpperCase());
/**
 * Returns a Distribution that returns a random string comprised of numbers
 * or the characters `abcdef` (or `ABCDEF`) of length `length`.
 * @param length Length of the result string
 * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`
 */ function hex(uppercase) {
    if (uppercase) {
        return upperHex;
    } else {
        return lowerHex;
    }
}
function convertSliceArgument(value, length) {
    if (value < 0) {
        return Math.max(value + length, 0);
    } else {
        return Math.min(value, length);
    }
}
function toInteger(value) {
    const num = +value;
    if (num < 0) {
        return Math.ceil(num);
    } else {
        return Math.floor(num);
    }
}
/**
 * Returns a random value within the provided `source` within the sliced
 * bounds of `begin` and `end`.
 * @param source an array of items to pick from
 * @param begin the beginning slice index (defaults to `0`)
 * @param end the ending slice index (defaults to `source.length`)
 */ function pick(engine, source, begin, end) {
    const length = source.length;
    if (length === 0) {
        throw new RangeError("Cannot pick from an empty array");
    }
    const start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
    const finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);
    if (start >= finish) {
        throw new RangeError(`Cannot pick between bounds ${start} and ${finish}`);
    }
    const distribution = integer(start, finish - 1);
    return source[distribution(engine)];
}
function multiply(distribution, multiplier) {
    if (multiplier === 1) {
        return distribution;
    } else if (multiplier === 0) {
        return ()=>0;
    } else {
        return (engine)=>distribution(engine) * multiplier;
    }
}
/**
 * Returns a floating-point value within [0.0, 1.0)
 */ function realZeroToOneExclusive(engine) {
    return uint53(engine) / SMALLEST_UNSAFE_INTEGER;
}
/**
 * Returns a floating-point value within [0.0, 1.0]
 */ function realZeroToOneInclusive(engine) {
    return uint53Full(engine) / SMALLEST_UNSAFE_INTEGER;
}
/**
 * Returns a floating-point value within [min, max) or [min, max]
 * @param min The minimum floating-point value, inclusive.
 * @param max The maximum floating-point value.
 * @param inclusive If true, `max` will be inclusive.
 */ function real(min, max, inclusive = false) {
    if (!isFinite(min)) {
        throw new RangeError("Expected min to be a finite number");
    } else if (!isFinite(max)) {
        throw new RangeError("Expected max to be a finite number");
    }
    return add(multiply(inclusive ? realZeroToOneInclusive : realZeroToOneExclusive, max - min), min);
}
const sliceArray = Array.prototype.slice;
/**
 * Shuffles an array in-place
 * @param engine The Engine to use when choosing random values
 * @param array The array to shuffle
 * @param downTo minimum index to shuffle. Only used internally.
 */ function shuffle(engine, array, downTo = 0) {
    const length = array.length;
    if (length) {
        for(let i = length - 1 >>> 0; i > downTo; --i){
            const distribution = integer(0, i);
            const j = distribution(engine);
            if (i !== j) {
                const tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
            }
        }
    }
    return array;
}
/**
 * From the population array, produce an array with sampleSize elements that
 * are randomly chosen without repeats.
 * @param engine The Engine to use when choosing random values
 * @param population An array that has items to choose a sample from
 * @param sampleSize The size of the result array
 */ function sample(engine, population, sampleSize) {
    if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
        throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
    }
    if (sampleSize === 0) {
        return [];
    }
    const clone = sliceArray.call(population);
    const length = clone.length;
    if (length === sampleSize) {
        return shuffle(engine, clone, 0);
    }
    const tailLength = length - sampleSize;
    return shuffle(engine, clone, tailLength - 1).slice(tailLength);
}
const stringRepeat = (()=>{
    try {
        if ("x".repeat(3) === "xxx") {
            return (pattern, count)=>pattern.repeat(count);
        }
    } catch (_) {
    // nothing to do here
    }
    return (pattern, count)=>{
        let result = "";
        while(count > 0){
            if (count & 1) {
                result += pattern;
            }
            count >>= 1;
            pattern += pattern;
        }
        return result;
    };
})();
function zeroPad(text, zeroCount) {
    return stringRepeat("0", zeroCount - text.length) + text;
}
/**
 * Returns a Universally Unique Identifier Version 4.
 *
 * See http://en.wikipedia.org/wiki/Universally_unique_identifier
 */ function uuid4(engine) {
    const a = engine.next() >>> 0;
    const b = engine.next() | 0;
    const c = engine.next() | 0;
    const d = engine.next() >>> 0;
    return zeroPad(a.toString(16), 8) + "-" + zeroPad((b & 0xffff).toString(16), 4) + "-" + zeroPad((b >> 4 & 0x0fff | 0x4000).toString(16), 4) + "-" + zeroPad((c & 0x3fff | 0x8000).toString(16), 4) + "-" + zeroPad((c >> 4 & 0xffff).toString(16), 4) + zeroPad(d.toString(16), 8);
}
/**
 * An int32-producing Engine that uses `Math.random()`
 */ const nativeMath = {
    next () {
        return Math.random() * UINT32_SIZE | 0;
    }
};
// tslint:disable:unified-signatures
/**
 * A wrapper around an Engine that provides easy-to-use methods for
 * producing values based on known distributions
 */ class Random {
    /**
     * Creates a new Random wrapper
     * @param engine The engine to use (defaults to a `Math.random`-based implementation)
     */ constructor(engine = nativeMath){
        this.engine = engine;
    }
    /**
     * Returns a value within [-0x80000000, 0x7fffffff]
     */ int32() {
        return int32(this.engine);
    }
    /**
     * Returns a value within [0, 0xffffffff]
     */ uint32() {
        return uint32(this.engine);
    }
    /**
     * Returns a value within [0, 0x1fffffffffffff]
     */ uint53() {
        return uint53(this.engine);
    }
    /**
     * Returns a value within [0, 0x20000000000000]
     */ uint53Full() {
        return uint53Full(this.engine);
    }
    /**
     * Returns a value within [-0x20000000000000, 0x1fffffffffffff]
     */ int53() {
        return int53(this.engine);
    }
    /**
     * Returns a value within [-0x20000000000000, 0x20000000000000]
     */ int53Full() {
        return int53Full(this.engine);
    }
    /**
     * Returns a value within [min, max]
     * @param min The minimum integer value, inclusive. No less than -0x20000000000000.
     * @param max The maximum integer value, inclusive. No greater than 0x20000000000000.
     */ integer(min, max) {
        return integer(min, max)(this.engine);
    }
    /**
     * Returns a floating-point value within [0.0, 1.0]
     */ realZeroToOneInclusive() {
        return realZeroToOneInclusive(this.engine);
    }
    /**
     * Returns a floating-point value within [0.0, 1.0)
     */ realZeroToOneExclusive() {
        return realZeroToOneExclusive(this.engine);
    }
    /**
     * Returns a floating-point value within [min, max) or [min, max]
     * @param min The minimum floating-point value, inclusive.
     * @param max The maximum floating-point value.
     * @param inclusive If true, `max` will be inclusive.
     */ real(min, max, inclusive = false) {
        return real(min, max, inclusive)(this.engine);
    }
    bool(numerator, denominator) {
        return bool(numerator, denominator)(this.engine);
    }
    /**
     * Return a random value within the provided `source` within the sliced
     * bounds of `begin` and `end`.
     * @param source an array of items to pick from
     * @param begin the beginning slice index (defaults to `0`)
     * @param end the ending slice index (defaults to `source.length`)
     */ pick(source, begin, end) {
        return pick(this.engine, source, begin, end);
    }
    /**
     * Shuffles an array in-place
     * @param array The array to shuffle
     */ shuffle(array) {
        return shuffle(this.engine, array);
    }
    /**
     * From the population array, returns an array with sampleSize elements that
     * are randomly chosen without repeats.
     * @param population An array that has items to choose a sample from
     * @param sampleSize The size of the result array
     */ sample(population, sampleSize) {
        return sample(this.engine, population, sampleSize);
    }
    /**
     * Returns a value within [1, sideCount]
     * @param sideCount The number of sides of the die
     */ die(sideCount) {
        return die(sideCount)(this.engine);
    }
    /**
     * Returns an array of length `dieCount` of values within [1, sideCount]
     * @param sideCount The number of sides of each die
     * @param dieCount The number of dice
     */ dice(sideCount, dieCount) {
        return dice(sideCount, dieCount)(this.engine);
    }
    /**
     * Returns a Universally Unique Identifier Version 4.
     *
     * See http://en.wikipedia.org/wiki/Universally_unique_identifier
     */ uuid4() {
        return uuid4(this.engine);
    }
    string(length, pool) {
        return string(pool)(this.engine, length);
    }
    /**
     * Returns a random string comprised of numbers or the characters `abcdef`
     * (or `ABCDEF`) of length `length`.
     * @param length Length of the result string
     * @param uppercase Whether the string should use `ABCDEF` instead of `abcdef`
     */ hex(length, uppercase) {
        return hex(uppercase)(this.engine, length);
    }
    /**
     * Returns a random `Date` within the inclusive range of [`start`, `end`].
     * @param start The minimum `Date`
     * @param end The maximum `Date`
     */ date(start, end) {
        return date(start, end)(this.engine);
    }
}
/**
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array
 */ const I32Array = (()=>{
    try {
        const buffer = new ArrayBuffer(4);
        const view = new Int32Array(buffer);
        view[0] = INT32_SIZE;
        if (view[0] === -INT32_SIZE) {
            return Int32Array;
        }
    } catch (_) {
    // nothing to do here
    }
    return Array;
})();
let data = null;
const COUNT = 128;
let index = COUNT;
/**
 * An Engine that relies on the globally-available `crypto.getRandomValues`,
 * which is typically available in modern browsers.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 *
 * If unavailable or otherwise non-functioning, then `browserCrypto` will
 * likely `throw` on the first call to `next()`.
 */ const browserCrypto = {
    next () {
        if (index >= COUNT) {
            if (data === null) {
                data = new I32Array(COUNT);
            }
            crypto.getRandomValues(data);
            index = 0;
        }
        return data[index++] | 0;
    }
};
/**
 * Returns an array of random int32 values, based on current time
 * and a random number engine
 *
 * @param engine an Engine to pull random values from, default `nativeMath`
 * @param length the length of the Array, minimum 1, default 16
 */ function createEntropy(engine = nativeMath, length = 16) {
    const array = [];
    array.push(new Date().getTime() | 0);
    for(let i = 1; i < length; ++i){
        array[i] = engine.next() | 0;
    }
    return array;
}
/**
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
 */ const imul = (()=>{
    try {
        if (Math.imul(UINT32_MAX, 5) === -5) {
            return Math.imul;
        }
    } catch (_) {
    // nothing to do here
    }
    const UINT16_MAX = 0xffff;
    return (a, b)=>{
        const ah = a >>> 16 & UINT16_MAX;
        const al = a & UINT16_MAX;
        const bh = b >>> 16 & UINT16_MAX;
        const bl = b & UINT16_MAX;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    };
})();
const ARRAY_SIZE = 624;
const ARRAY_MAX = ARRAY_SIZE - 1;
const M = 397;
const ARRAY_SIZE_MINUS_M = ARRAY_SIZE - M;
const A = 0x9908b0df;
/**
 * An Engine that is a pseudorandom number generator using the Mersenne
 * Twister algorithm based on the prime 2**19937  1
 *
 * See http://en.wikipedia.org/wiki/Mersenne_twister
 */ class MersenneTwister19937 {
    /**
     * MersenneTwister19937 should not be instantiated directly.
     * Instead, use the static methods `seed`, `seedWithArray`, or `autoSeed`.
     */ constructor(){
        this.data = new I32Array(ARRAY_SIZE);
        this.index = 0; // integer within [0, 624]
        this.uses = 0;
    }
    /**
     * Returns a MersenneTwister19937 seeded with an initial int32 value
     * @param initial the initial seed value
     */ static seed(initial) {
        return new MersenneTwister19937().seed(initial);
    }
    /**
     * Returns a MersenneTwister19937 seeded with zero or more int32 values
     * @param source A series of int32 values
     */ static seedWithArray(source) {
        return new MersenneTwister19937().seedWithArray(source);
    }
    /**
     * Returns a MersenneTwister19937 seeded with the current time and
     * a series of natively-generated random values
     */ static autoSeed() {
        return MersenneTwister19937.seedWithArray(createEntropy());
    }
    /**
     * Returns the next int32 value of the sequence
     */ next() {
        if ((this.index | 0) >= ARRAY_SIZE) {
            refreshData(this.data);
            this.index = 0;
        }
        const value = this.data[this.index];
        this.index = this.index + 1 | 0;
        this.uses += 1;
        return temper(value) | 0;
    }
    /**
     * Returns the number of times that the Engine has been used.
     *
     * This can be provided to an unused MersenneTwister19937 with the same
     * seed, bringing it to the exact point that was left off.
     */ getUseCount() {
        return this.uses;
    }
    /**
     * Discards one or more items from the engine
     * @param count The count of items to discard
     */ discard(count) {
        if (count <= 0) {
            return this;
        }
        this.uses += count;
        if ((this.index | 0) >= ARRAY_SIZE) {
            refreshData(this.data);
            this.index = 0;
        }
        while(count + this.index > ARRAY_SIZE){
            count -= ARRAY_SIZE - this.index;
            refreshData(this.data);
            this.index = 0;
        }
        this.index = this.index + count | 0;
        return this;
    }
    seed(initial) {
        let previous = 0;
        this.data[0] = previous = initial | 0;
        for(let i = 1; i < ARRAY_SIZE; i = i + 1 | 0){
            this.data[i] = previous = imul(previous ^ previous >>> 30, 0x6c078965) + i | 0;
        }
        this.index = ARRAY_SIZE;
        this.uses = 0;
        return this;
    }
    seedWithArray(source) {
        this.seed(0x012bd6aa);
        seedWithArray(this.data, source);
        return this;
    }
}
function refreshData(data) {
    let k = 0;
    let tmp = 0;
    for(; (k | 0) < ARRAY_SIZE_MINUS_M; k = k + 1 | 0){
        tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
        data[k] = data[k + M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
    }
    for(; (k | 0) < ARRAY_MAX; k = k + 1 | 0){
        tmp = data[k] & INT32_SIZE | data[k + 1 | 0] & INT32_MAX;
        data[k] = data[k - ARRAY_SIZE_MINUS_M | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
    }
    tmp = data[ARRAY_MAX] & INT32_SIZE | data[0] & INT32_MAX;
    data[ARRAY_MAX] = data[M - 1] ^ tmp >>> 1 ^ (tmp & 0x1 ? A : 0);
}
function temper(value) {
    value ^= value >>> 11;
    value ^= value << 7 & 0x9d2c5680;
    value ^= value << 15 & 0xefc60000;
    return value ^ value >>> 18;
}
function seedWithArray(data, source) {
    let i = 1;
    let j = 0;
    const sourceLength = source.length;
    let k = Math.max(sourceLength, ARRAY_SIZE) | 0;
    let previous = data[0] | 0;
    for(; (k | 0) > 0; --k){
        data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x0019660d)) + (source[j] | 0) + (j | 0) | 0;
        i = i + 1 | 0;
        ++j;
        if ((i | 0) > ARRAY_MAX) {
            data[0] = data[ARRAY_MAX];
            i = 1;
        }
        if (j >= sourceLength) {
            j = 0;
        }
    }
    for(k = ARRAY_MAX; (k | 0) > 0; --k){
        data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x5d588b65)) - i | 0;
        i = i + 1 | 0;
        if ((i | 0) > ARRAY_MAX) {
            data[0] = data[ARRAY_MAX];
            i = 1;
        }
    }
    data[0] = INT32_SIZE;
}
let data$1 = null;
const COUNT$1 = 128;
let index$1 = COUNT$1;
/**
 * An Engine that relies on the node-available
 * `require('crypto').randomBytes`, which has been available since 0.58.
 *
 * See https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback
 *
 * If unavailable or otherwise non-functioning, then `nodeCrypto` will
 * likely `throw` on the first call to `next()`.
 */ const nodeCrypto = {
    next () {
        if (index$1 >= COUNT$1) {
            data$1 = new Int32Array(new Int8Array(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)").randomBytes(4 * COUNT$1)).buffer);
            index$1 = 0;
        }
        return data$1[index$1++] | 0;
    }
};
/**
 * Returns a Distribution to random value within the provided `source`
 * within the sliced bounds of `begin` and `end`.
 * @param source an array of items to pick from
 * @param begin the beginning slice index (defaults to `0`)
 * @param end the ending slice index (defaults to `source.length`)
 */ function picker(source, begin, end) {
    const clone = sliceArray.call(source, begin, end);
    if (clone.length === 0) {
        throw new RangeError(`Cannot pick from a source with no items`);
    }
    const distribution = integer(0, clone.length - 1);
    return (engine)=>clone[distribution(engine)];
}
;
 //# sourceMappingURL=random-js.esm.js.map
}}),
"[project]/node_modules/ml-random-forest/src/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "checkFloat": (()=>checkFloat),
    "collectOOB": (()=>collectOOB),
    "examplesBaggingWithReplacement": (()=>examplesBaggingWithReplacement),
    "featureBagging": (()=>featureBagging),
    "isFloat": (()=>isFloat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/random-js/dist/random-js.esm.js [app-client] (ecmascript)");
;
;
function checkFloat(n) {
    return n > 0.0 && n <= 1.0;
}
function isFloat(n) {
    return Number(n) === n && n % 1 !== 0;
}
function examplesBaggingWithReplacement(trainingSet, trainingValue, seed) {
    let engine;
    let distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["integer"])(0, trainingSet.rows - 1);
    if (seed === undefined) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].autoSeed();
    } else if (Number.isInteger(seed)) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].seed(seed);
    } else {
        throw new RangeError(`Expected seed must be undefined or integer not ${seed}`);
    }
    let Xr = new Array(trainingSet.rows);
    let yr = new Array(trainingSet.rows);
    let oob = new Array(trainingSet.rows).fill(0);
    let oobN = trainingSet.rows;
    for(let i = 0; i < trainingSet.rows; ++i){
        let index = distribution(engine);
        Xr[i] = trainingSet.getRow(index);
        yr[i] = trainingValue[index];
        if (oob[index]++ === 0) {
            oobN--;
        }
    }
    let Xoob = new Array(oobN);
    let ioob = new Array(oobN);
    // run backwards to have ioob filled in increasing order
    for(let i = trainingSet.rows - 1; i >= 0 && oobN > 0; --i){
        if (oob[i] === 0) {
            Xoob[--oobN] = trainingSet.getRow(i);
            ioob[oobN] = i;
        }
    }
    return {
        X: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](Xr),
        y: yr,
        Xoob: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](Xoob),
        ioob,
        seed: engine.next()
    };
}
function featureBagging(trainingSet, n, replacement, seed) {
    if (trainingSet.columns < n) {
        throw new RangeError('N should be less or equal to the number of columns of X');
    }
    let distribution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["integer"])(0, trainingSet.columns - 1);
    let engine;
    if (seed === undefined) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].autoSeed();
    } else if (Number.isInteger(seed)) {
        engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$random$2d$js$2f$dist$2f$random$2d$js$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MersenneTwister19937"].seed(seed);
    } else {
        throw new RangeError(`Expected seed must be undefined or integer not ${seed}`);
    }
    let toRet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](trainingSet.rows, n);
    let usedIndex;
    let index;
    if (replacement) {
        usedIndex = new Array(n);
        for(let i = 0; i < n; ++i){
            index = distribution(engine);
            usedIndex[i] = index;
            toRet.setColumn(i, trainingSet.getColumn(index));
        }
    } else {
        usedIndex = new Set();
        index = distribution(engine);
        for(let i = 0; i < n; ++i){
            while(usedIndex.has(index)){
                index = distribution(engine);
            }
            toRet.setColumn(i, trainingSet.getColumn(index));
            usedIndex.add(index);
        }
        usedIndex = Array.from(usedIndex);
    }
    return {
        X: toRet,
        usedIndex: usedIndex,
        seed: engine.next()
    };
}
const collectOOB = (oob, y, aggregate)=>{
    const res = Array(y.length);
    for(let i = 0; i < y.length; i++){
        const all = [];
        for(let j = 0; j < oob.length; j++){
            const o = oob[j];
            if (o.index[0] === i) {
                all.push(o.predicted[0]);
                o.index = o.index.slice(1);
                o.predicted = o.predicted.slice(1);
            }
        }
        res[i] = {
            true: y[i],
            all: all,
            predicted: aggregate(all)
        };
    }
    return res;
};
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestBase": (()=>RandomForestBase)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-cart/src/DecisionTreeRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-matrix/matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/utils.js [app-client] (ecmascript)");
;
;
;
class RandomForestBase {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number|String} [options.maxFeatures] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement] - use replacement over the sample features.
   * @param {number} [options.seed] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators] - number of estimator to use.
   * @param {object} [options.treeOptions] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {boolean} [options.isClassifier] - boolean to check if is a classifier or regression model (used by subclasses).
   * @param {boolean} [options.useSampleBagging] - use bagging over training samples.
   * @param {boolean} [options.noOOB] - don't calculate Out-Of-Bag predictions.
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            this.replacement = model.replacement;
            this.maxFeatures = model.maxFeatures;
            this.nEstimators = model.nEstimators;
            this.treeOptions = model.treeOptions;
            this.isClassifier = model.isClassifier;
            this.seed = model.seed;
            this.n = model.n;
            this.indexes = model.indexes;
            this.useSampleBagging = model.useSampleBagging;
            this.noOOB = true;
            this.maxSamples = model.maxSamples;
            let Estimator = this.isClassifier ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeClassifier"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeRegression"];
            this.estimators = model.estimators.map((est)=>Estimator.load(est));
        } else {
            this.replacement = options.replacement;
            this.maxFeatures = options.maxFeatures;
            this.nEstimators = options.nEstimators;
            this.treeOptions = options.treeOptions;
            this.isClassifier = options.isClassifier;
            this.seed = options.seed;
            this.useSampleBagging = options.useSampleBagging;
            this.noOOB = options.noOOB;
            this.maxSamples = options.maxSamples;
        }
    }
    /**
   * Train the decision tree with the given training set and labels.
   * @param {Matrix|Array} trainingSet
   * @param {Array} trainingValues
   */ train(trainingSet, trainingValues) {
        let currentSeed = this.seed;
        trainingSet = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(trainingSet);
        this.maxFeatures = this.maxFeatures || trainingSet.columns;
        this.numberFeatures = trainingSet.columns;
        this.numberSamples = trainingSet.rows;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkFloat"])(this.maxFeatures)) {
            this.n = Math.floor(trainingSet.columns * this.maxFeatures);
        } else if (Number.isInteger(this.maxFeatures)) {
            if (this.maxFeatures > trainingSet.columns) {
                throw new RangeError(`The maxFeatures parameter should be less than ${trainingSet.columns}`);
            } else {
                this.n = this.maxFeatures;
            }
        } else {
            throw new RangeError(`Cannot process the maxFeatures parameter ${this.maxFeatures}`);
        }
        if (this.maxSamples) {
            if (this.maxSamples < 0) {
                throw new RangeError(`Please choose a positive value for maxSamples`);
            } else {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFloat"])(this.maxSamples)) {
                    if (this.maxSamples > 1.0) {
                        throw new RangeError('Please choose either a float value between 0 and 1 or a positive integer for maxSamples');
                    } else {
                        this.numberSamples = Math.floor(trainingSet.rows * this.maxSamples);
                    }
                } else if (Number.isInteger(this.maxSamples)) {
                    if (this.maxSamples > trainingSet.rows) {
                        throw new RangeError(`The maxSamples parameter should be less than ${trainingSet.rows}`);
                    } else {
                        this.numberSamples = this.maxSamples;
                    }
                }
            }
        }
        if (this.maxSamples) {
            if (trainingSet.rows !== this.numberSamples) {
                let tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](this.numberSamples, trainingSet.columns);
                for(let j = 0; j < this.numberSamples; j++){
                    tmp.removeRow(0);
                }
                for(let i = 0; i < this.numberSamples; i++){
                    tmp.addRow(trainingSet.getRow(i));
                }
                trainingSet = tmp;
                trainingValues = trainingValues.slice(0, this.numberSamples);
            }
        }
        let Estimator;
        if (this.isClassifier) {
            Estimator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeClassifier"];
        } else {
            Estimator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$cart$2f$src$2f$DecisionTreeRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecisionTreeRegression"];
        }
        this.estimators = new Array(this.nEstimators);
        this.indexes = new Array(this.nEstimators);
        let oobResults = new Array(this.nEstimators);
        for(let i = 0; i < this.nEstimators; ++i){
            let res = this.useSampleBagging ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["examplesBaggingWithReplacement"])(trainingSet, trainingValues, currentSeed) : {
                X: trainingSet,
                y: trainingValues,
                seed: currentSeed,
                Xoob: undefined,
                yoob: [],
                ioob: []
            };
            let X = res.X;
            let y = res.y;
            currentSeed = res.seed;
            let { Xoob, ioob } = res;
            // Other implementations of random forests apply feature bagging at every split during tree generation.
            // So I think it would be better to implement it at the CART level, not here.
            res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureBagging"])(X, this.n, this.replacement, currentSeed);
            X = res.X;
            currentSeed = res.seed;
            this.indexes[i] = res.usedIndex;
            this.estimators[i] = new Estimator(this.treeOptions);
            this.estimators[i].train(X, y);
            if (!this.noOOB && this.useSampleBagging) {
                let xoob = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixColumnSelectionView"](Xoob, this.indexes[i]);
                oobResults[i] = {
                    index: ioob,
                    predicted: this.estimators[i].predict(xoob)
                };
            }
        }
        if (!this.noOOB && this.useSampleBagging && oobResults.length > 0) {
            this.oobResults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectOOB"])(oobResults, trainingValues, this.selection.bind(this));
        }
    }
    /**
   * Evaluate the feature importances for each tree in the ensemble
   * @return {Array} feature importances
   */ featureImportance() {
        const trees = JSON.parse(JSON.stringify(this.estimators));
        const indexes = JSON.parse(JSON.stringify(this.indexes));
        let importance = [];
        function computeFeatureImportances(i, node) {
            // node.gain can be null or undefined
            if (!node || !('splitColumn' in node) || !(node.gain > 0)) return;
            let f = node.gain * node.numberSamples;
            if ('left' in node) {
                f -= (node.left.gain || 0) * (node.left.numberSamples || 0);
            }
            if ('right' in node) {
                f -= (node.right.gain || 0) * (node.right.numberSamples || 0);
            }
            importance[i][node.splitColumn] += f;
            if (node.left) {
                computeFeatureImportances(i, node.left);
            }
            if (node.right) {
                computeFeatureImportances(i, node.right);
            }
        }
        function normalizeImportances(i) {
            const s = importance[i].reduce((cum, v)=>{
                return cum += v;
            }, 0);
            importance[i] = importance[i].map((v)=>{
                return v / s;
            });
        }
        for(let i = 0; i < trees.length; i++){
            importance.push(new Array(this.numberFeatures).fill(0.0));
            computeFeatureImportances(i, trees[i].root);
            normalizeImportances(i);
        }
        let avgImportance = new Array(this.numberFeatures).fill(0.0);
        for(let i = 0; i < importance.length; i++){
            for(let x = 0; x < this.numberFeatures; x++){
                avgImportance[indexes[i][x]] += importance[i][x];
            }
        }
        const s = avgImportance.reduce((cum, v)=>{
            return cum += v;
        }, 0);
        return avgImportance.map((v)=>{
            return v / s;
        });
    }
    /**
   * Method that returns the way the algorithm generates the predictions, for example, in classification
   * you can return the mode of all predictions retrieved by the trees, or in case of regression you can
   * use the mean or the median.
   * @abstract
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction.
   */ // eslint-disable-next-line no-unused-vars
    selection(values) {
        throw new Error("Abstract method 'selection' not implemented!");
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @return {Array} predictions
   */ predict(toPredict) {
        const predictionValues = this.predictionValues(toPredict);
        let predictions = new Array(predictionValues.rows);
        for(let i = 0; i < predictionValues.rows; ++i){
            predictions[i] = this.selection(predictionValues.getRow(i));
        }
        return predictions;
    }
    /**
   * Predicts the output given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @return {MatrixTransposeView} predictions of estimators
   */ predictionValues(toPredict) {
        let predictionValues = new Array(this.nEstimators);
        toPredict = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].checkMatrix(toPredict);
        for(let i = 0; i < this.nEstimators; ++i){
            let X = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixColumnSelectionView"](toPredict, this.indexes[i]);
            predictionValues[i] = this.estimators[i].predict(X);
        }
        return predictionValues = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixTransposeView"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$matrix$2f$matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WrapperMatrix2D"](predictionValues));
    }
    /**
   * Returns the Out-Of-Bag predictions.
   * @return {Array} predictions
   */ predictOOB() {
        if (!this.oobResults || this.oobResults.length === 0) {
            throw new Error('No Out-Of-Bag results found. Did you forgot to train first?');
        }
        return this.oobResults.map((v)=>v.predicted);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        return {
            indexes: this.indexes,
            n: this.n,
            replacement: this.replacement,
            maxFeatures: this.maxFeatures,
            nEstimators: this.nEstimators,
            treeOptions: this.treeOptions,
            isClassifier: this.isClassifier,
            seed: this.seed,
            estimators: this.estimators.map((est)=>est.toJSON()),
            useSampleBagging: this.useSampleBagging
        };
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestClassifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestClassifier": (()=>RandomForestClassifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mode$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mode/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)");
;
;
const defaultOptions = {
    maxFeatures: 1.0,
    replacement: true,
    nEstimators: 50,
    seed: 42,
    useSampleBagging: true,
    noOOB: false
};
class RandomForestClassifier extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomForestBase"] {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number} [options.maxFeatures=1.0] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement=true] - use replacement over the sample features.
   * @param {number} [options.seed=42] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators=50] - number of estimator to use.
   * @param {object} [options.treeOptions={}] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {boolean} [options.useSampleBagging=true] - use bagging over training samples.
   * @param {number} [options.maxSamples=null] - if null, then draw X.shape[0] samples. If int, then draw maxSamples samples. If float, then draw maxSamples * X.shape[0] samples. Thus, maxSamples should be in the interval (0.0, 1.0].
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            super(true, model.baseModel);
        } else {
            options = Object.assign({}, defaultOptions, options);
            options.isClassifier = true;
            super(options);
        }
    }
    /**
   * retrieve the prediction given the selection method.
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction
   */ selection(values) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mode$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        let baseModel = super.toJSON();
        return {
            baseModel: baseModel,
            name: 'RFClassifier'
        };
    }
    /**
   * Returns the confusion matrix
   * Make sure to run train first.
   * @return {object} - Current model.
   */ getConfusionMatrix() {
        if (!this.oobResults) {
            throw new Error('No Out-Of-Bag results available.');
        }
        const labels = new Set();
        const matrix = this.oobResults.reduce((p, v)=>{
            labels.add(v.true);
            labels.add(v.predicted);
            const x = p[v.predicted] || {};
            x[v.true] = (x[v.true] || 0) + 1;
            p[v.predicted] = x;
            return p;
        }, {});
        const sortedLabels = [
            ...labels
        ].sort();
        return sortedLabels.map((v)=>sortedLabels.map((w)=>(matrix[v] || {})[w] || 0));
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {RandomForestClassifier}
   */ static load(model) {
        if (model.name !== 'RFClassifier') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new RandomForestClassifier(true, model);
    }
    /**
   * Predicts the probability of a label given the matrix to predict.
   * @param {Matrix|Array} toPredict
   * @param {number} label
   * @return {Array} predictions
   */ predictProbability(toPredict, label) {
        const predictionValues = this.predictionValues(toPredict);
        let predictions = new Array(predictionValues.rows);
        for(let i = 0; i < predictionValues.rows; ++i){
            const pvs = predictionValues.getRow(i);
            const l = pvs.length;
            const roundFactor = Math.pow(10, 6);
            predictions[i] = Math.round(pvs.reduce((p, v)=>{
                if (v === label) {
                    p += roundFactor / l;
                }
                return p;
            })) / roundFactor;
        }
        return predictions;
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/RandomForestRegression.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RandomForestRegression": (()=>RandomForestRegression)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-mean/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$median$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-array-median/lib-es6/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestBase.js [app-client] (ecmascript)");
;
;
;
const selectionMethods = {
    mean: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$mean$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    median: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$array$2d$median$2f$lib$2d$es6$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
};
const defaultOptions = {
    maxFeatures: 1.0,
    replacement: false,
    nEstimators: 50,
    treeOptions: {},
    selectionMethod: 'mean',
    seed: 42,
    useSampleBagging: true,
    noOOB: false
};
class RandomForestRegression extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomForestBase"] {
    /**
   * Create a new base random forest for a classifier or regression model.
   * @constructor
   * @param {object} options
   * @param {number} [options.maxFeatures=1.0] - the number of features used on each estimator.
   *        * if is an integer it selects maxFeatures elements over the sample features.
   *        * if is a float between (0, 1), it takes the percentage of features.
   * @param {boolean} [options.replacement=true] - use replacement over the sample features.
   * @param {number} [options.seed=42] - seed for feature and samples selection, must be a 32-bit integer.
   * @param {number} [options.nEstimators=50] - number of estimator to use.
   * @param {object} [options.treeOptions={}] - options for the tree classifier, see [ml-cart]{@link https://mljs.github.io/decision-tree-cart/}
   * @param {string} [options.selectionMethod="mean"] - the way to calculate the prediction from estimators, "mean" and "median" are supported.
   * @param {boolean} [options.useSampleBagging=true] - use bagging over training samples.
   * @param {number} [options.maxSamples=null] - if null, then draw X.shape[0] samples. If int, then draw maxSamples samples. If float, then draw maxSamples * X.shape[0] samples. Thus, maxSamples should be in the interval (0.0, 1.0].
   * @param {object} model - for load purposes.
   */ constructor(options, model){
        if (options === true) {
            super(true, model.baseModel);
            this.selectionMethod = model.selectionMethod;
        } else {
            options = Object.assign({}, defaultOptions, options);
            if (!(options.selectionMethod === 'mean' || options.selectionMethod === 'median')) {
                throw new RangeError(`Unsupported selection method ${options.selectionMethod}`);
            }
            options.isClassifier = false;
            super(options);
            this.selectionMethod = options.selectionMethod;
        }
    }
    /**
   * retrieve the prediction given the selection method.
   * @param {Array} values - predictions of the estimators.
   * @return {number} prediction
   */ selection(values) {
        return selectionMethods[this.selectionMethod](values);
    }
    /**
   * Export the current model to JSON.
   * @return {object} - Current model.
   */ toJSON() {
        let baseModel = super.toJSON();
        return {
            baseModel: baseModel,
            selectionMethod: this.selectionMethod,
            name: 'RFRegression'
        };
    }
    /**
   * Load a Decision tree classifier with the given model.
   * @param {object} model
   * @return {RandomForestRegression}
   */ static load(model) {
        if (model.name !== 'RFRegression') {
            throw new RangeError(`Invalid model: ${model.name}`);
        }
        return new RandomForestRegression(true, model);
    }
}
}}),
"[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
}}),
"[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestClassifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestClassifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$RandomForestRegression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/RandomForestRegression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ml$2d$random$2d$forest$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ml-random-forest/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/median-quickselect/lib/median-quickselect.min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    function a(d) {
        for(var e = 0, f = d.length - 1, g = void 0, h = void 0, i = void 0, j = c(e, f); !0;){
            if (f <= e) return d[j];
            if (f == e + 1) return d[e] > d[f] && b(d, e, f), d[j];
            for(g = c(e, f), d[g] > d[f] && b(d, g, f), d[e] > d[f] && b(d, e, f), d[g] > d[e] && b(d, g, e), b(d, g, e + 1), h = e + 1, i = f; !0;){
                do h++;
                while (d[e] > d[h])
                do i--;
                while (d[i] > d[e])
                if (i < h) break;
                b(d, h, i);
            }
            b(d, e, i), i <= j && (e = h), i >= j && (f = i - 1);
        }
    }
    var b = function b(d, e, f) {
        var _ref;
        return _ref = [
            d[f],
            d[e]
        ], d[e] = _ref[0], d[f] = _ref[1], _ref;
    }, c = function c(d, e) {
        return ~~((d + e) / 2);
    };
    'undefined' != ("TURBOPACK compile-time value", "object") && module.exports ? module.exports = a : window.median = a;
})();
}}),
"[project]/node_modules/ml-array-median/lib-es6/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>median)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-any-array/lib-esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$median$2d$quickselect$2f$lib$2f$median$2d$quickselect$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/median-quickselect/lib/median-quickselect.min.js [app-client] (ecmascript)");
;
;
function median(input) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$any$2d$array$2f$lib$2d$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnyArray"])(input)) {
        throw new TypeError('input must be an array');
    }
    if (input.length === 0) {
        throw new TypeError('input must not be empty');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$median$2d$quickselect$2f$lib$2f$median$2d$quickselect$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input.slice());
}
;
}}),
}]);

//# sourceMappingURL=node_modules_94d6d10e._.js.map